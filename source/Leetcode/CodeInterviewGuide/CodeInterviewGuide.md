# The Code Interview Guide





# 第一章 栈和队列

本章总共11题



## 1.1  设计一个有getMin功能的栈

【题目】实现一个特殊的栈，在实现栈的基本功能的基础上，再实现返回栈中最小元素的操作。

【要求】

【1】  `pop`，`push`，`getMin`操作的时间复杂度O(1)

【2】  设计的栈类型可以使用现成的栈结构



## 1.2  由两个栈组成的队列

【题目】编写一个类，用两个栈实现队列，支持队列的基本操作（`push`，`pop`，`front`，`back`）



## 1.3  如何仅用递归函数和栈操作逆序一个栈

一个栈依次压入1,2,3,4,5，那么从栈顶到栈底就依次为5,4,3,2,1。将这个站逆转后，从栈顶到栈底依次是1,2,3,4,5，即实现栈中元素的逆序，但是仅能用递归函数来实现，不能使用其他数据结构。



## 1.4  猫狗队列

宠物，狗和猫的类如下：

```cpp
class Pet {
public:
   Pet(std::string type) {
       this->type = type;
   }
   std::string getPetType() {
        return this->type;
   }

private:
   std::string type;
};


class Dog : public class Pet {
public:
	Dog() : Pet("dog") {}
};

class Cat : public class Pet {
public:
   Cat() : Pet("cat") {}
};
```



实现一种狗猫队列，要求如下：

（1）  用户可以调用`add`方法将cat类或dog类的实例放入队列中

（2）  用户可以调用`pollAll`方法，将队列中的所有实例按照进队列的先后顺序依次弹出

（3）  用户可以调用`pollDog`方法，将队列中Dog类的所有实例按照进队列的先后顺序依次弹出

（4）  用户可以调用`pollCat`方法，将队列中Cat类的所有实例按照进队列的先后顺序依次弹出

（5）  用户可以调用`isEmpty`方法，检查队列中是否还有Dog类或者Cat类的实例

（6）  用户可以调用`isDogEmpty`方法，检查队列中是否还有Dog类的实例

（7）  用户可以调用`isCatEmpty`方法，检查队列中是否还有Cat类的实例



## 1.5  用一个栈实现另一个站的排序

【题目】一个栈中的元素为整型，现在想将该栈从顶到底按照从大到小的顺序排序，只允许申请一个栈。除此之外，可以申请新的变量，但不能申请额外的数据结构。然后完成排序？



## 1.6  用栈求解汉诺塔问题

【题目】汉诺塔问题比较经典，这里修改一下游戏规则：现在限制不能直接从最左侧的塔移动到最右侧，也不能直接从最右侧移动到最左侧，而是必须经过中间的塔。求当有N层塔时，打印最优移动过程和最优移动步数。

例如，当塔为两层时，最上层的塔记为1，最下层的塔记为2，则打印：

```bash
Move 1 from left to mid
Move 1 from mid to right
Move 2 from left to mid

Move 1 from right to mid
Move 1 from mid to left
Move 2 from mid to right
Move 1 from left to mid
Move 1 from mid to right

It will move 8 steps
```



【要求】方法一：使用递归的方法；方法二：使用非递归的方法，用栈来模拟汉诺塔的三个塔。



## 1.7  生成窗口最大值数组

【题目】有一个整型数组arr和一个大小为w的窗口从数组的最左边滑动到最右边，窗口每次向右滑动一个位置。

例如：数组为[4,3,5,4,3,3,6,7]，窗口大小为3时：

[4 3 5] 4 3 3 6 7 窗口中最大值为5

4 [3 5 4] 3 3 6 7 窗口中最大值为5

4 3 [5 4 3] 3 6 7 窗口中最大值为5

4 3 5 [4 3 3] 6 7 窗口中最大值为4

4 3 5 4 [3 3 6] 7 窗口中最大值为6

4 3 5 4 3 [3 6 7] 窗口中最大值为7

如果数组长度为n，窗口大小为w，则总共产生n-w+1个窗口的最大值。

请实现一个函数：

输入：整型数组arr，窗口大小为w。

输出：一个长度为n-w+1的数组res，res[i]表示每一种窗口状态下的最大值。

以本题为例，结果应该返回数组[5,5,5,4,6,7]



## 1.8  单调栈结构

【题目】给定一个不含有重复值的数组arr，找到每一个位置i左边和右边距离i位置最近且值比arr[i]小的位置。返回所有位置相应的信息。

【举例】arr = {3,4,1,5,6,2,7}，返回如下二维数组作为结果：

```bash
{
	{-1,2}，
	{0,2}，
	{-1,-1},
	{2,5},
	{3,5},
	{2,-1},
	{5,-1},
}
```

-1表示不存在。所以上面的结果表在arr中，0位置左边和右边距离0位置最近而且值比arr[0]小的位置是-1和2；1位置左边和右边距离1位置最近而且值比arr[1]小的位置是0和2；2位置左边和右边距离2位置最近而且值比arr[2]小的位置是-1和-1；……

【进阶问题】给定一个可能含有重复值的数组arr，找到每一个位置i左边和右边距离i位置最近且值比arr[i]小的位置。返回所有位置相应的信息。

【要求】如果arr长度为N，实现原问题和进阶问题的解法，时间复杂度都达到O(N)。



## 1.9  求最大子矩阵的大小

【题目】给定一个整型矩阵map，其中的值只有0和1两种，求其中全是1的所有矩形区域中，最大的矩形区域为1的数量。

例如：

1 1 1 0

其中，最大的矩形区域有3个，所有返回3。

再比如：

1 0 1 1

1 1 1 1

1 1 1 0

其中，最大的矩形区域有6个，所有返回6。



## 1.10 最大值减去最小值小于或等于num的子数组数量

给定数组arr和整数num，返回共有多少个子数组满足如下情况：

max{arr[i..j]} – min{arr[i..j]} <= num

max{arr[i..j]}是子数组arr[i..j]中的最大值，min{arr[i..j]}是子数组arr[i..j]中的最小值



## 1.11 可见的山峰对数量

一个不含有负数的数组可以代表一圈环形山，每个位置的值代表山的高度。比如{3,1,2,4,5}, {4,5,3,1,2}, {1,2,4,5,4}都代表同样的环形山。3->1->2->4->5->3方向是next方向（顺时针），3->5->4->2->1->3方向是last方向（逆时针）。

山峰A和山峰B能够相互看见的条件为：

\1.   如果A和B是同一座山，认为不能互相看见。

\2.   如果A和B是不同的山，并且在环中相邻，认为可以互相看见。

\3.   如果A和B是不同的山，并且在环中不相邻，假设两座山高度最小值为min。如果A通过next方向到B的途中没有高度比min大的山峰，或者A通过last方向到B的途中没有高度比min大的山峰，认为A和B可以互相看见。

给定一个不含有负数且没有重复值的数组，返回共有多少对山峰能够相互看见？

【进阶问题】给定一个不含有负数但可能有重复值的数组，返回共有多少对山峰能够相互看见？







# 第二章   链表问题

本章共20题



## 2.1  打印两个有序链表的公共部分

【题目】给定两个有序链表的头指针head1和head2，打印两个链表的公共部分



## 2.2  在单链表和双链表中删除倒数第K个节点

【题目】分布实现两个函数，一个可以删除单链表中倒数第K个节点，另一个可以删除双链表中倒数第K个节点。

【要求】如果链表长度为N，时间复杂度达到O(N)，额外空间复杂度达到O(1)。



## 2.3  删除链表的中间节点和a/b处的节点

【题目】给定链表的头节点head，实现删除链表的中间节点的函数。

例如：

（链表空）不删除任何节点；

1->2，删除节点1；

1->2->3，删除节点2；

1->2->3->4，删除节点2；

1->2->3->4->5，删除节点3；

【进阶】给定链表的头节点head、整数a和b，实现删除位于a/b处节点的函数。

例如：链表1->2->3->4->5，假设a/b的值为r。

如果r等于0，不删除任何节点；

如果r在区间(0, 1/5)上，删除节点1；

如果r在区间(1/5, 2/5]上，删除节点2；

如果r在区间(2/5, 3/5]上，删除节点3；

如果r在区间(3/5, 4/5]上，删除节点4；

如果r在区间(4/5, 1]上，删除节点5；

如果r大于1，不删除任何节点。



## 2.4  反转单向和双向链表

【题目】分别实现反转单向链表和反转双向链表的函数。

【要求】如果链表长度为N，时间复杂度要求为O(N)，额外空间复杂度要求为O(1)。



## 2.5  反转部分单向链表

【题目】给定一个单向链表的头节点head，以及两个整数from和to，在单向链表上把第from个节点到第to个节点这一部分进行反转。

例如

1->2->3->4->5->null，from=2， to=4

调整结果为：1->4->3->2->5->null

再如：

1->2->3->null，from=1， to=3

调整结果为：3->2->1->null



## 2.6  环形链表的约瑟夫问题

【题目】据说著名犹太历史学家Josephus有过一下故事：在罗马人占领乔塔帕特后，39个犹太人与Josephus以及他的朋友躲到一个洞中，39个犹太人决定宁愿死也不要被敌人抓到，于是决定了一种自杀方式，41个人排成一个圆圈，由第一个人开始报数，报数到3的人就自杀，然后再由下一个人重新报1，报数到3的人再自杀，这样依次下去，直到剩下最后一个人时，那个人可以自由选择自己的命运。这就是著名的约瑟夫问题。现在请用单向环形链表描述该结构并呈现整个自杀过程。

输入：一个环形单向链表的头节点head和报数的值m

返回：最后生存下来的节点，且这个节点自己最初环形单向链表，其他节点都删除掉。

【进阶】如果链表节点数为N，想在时间复杂度为O(N)时完成原问题的要求，该怎么实现？



## 2.7  判断一个链表是否为回文结构

【题目】给定一个链表的头节点head，请判断该链表是否为回文结构。

例如：

1->2->1，返回true。

1->2->2->1，返回true。

15->6->15，返回true。

1->2->3，返回false。

【进阶】如果链表长度为N，时间复杂度达到O(N)，额外空间复杂度达到O(1)。



## 2.8 将单向链表按照某值划分成左边小、中间相等、右边大的形式

【题目】给定一个单向链表的头节点head，节点的值类型是整型，在给定一个整数pivot。实现一个调整链表的函数，将链表调整为左部分都是值小于pivot的节点，中间部分都是值等于pivot的节点，右部分都是值大于pivot的节点。除这个要求外，对调整后的节点顺序没有更多的要求。

例如：链表9->0->4->5->1，pivot=3.

调整后链表可以是1->0->4->9->5，也可以是0->1->9->5->4。总之，满足左部分都是小于3的节点，中间部分都是等于3的节点（本例中这个部分为空），右部分都是大于3的节点即可，对某部分内部的节点顺序不做要求。

【进阶】在原问题的要求之上再增加如下两个要求

（1）    在左、中、右三个部分的内部也作顺序要求，要求每部分里的节点从左到右的顺序与原链表中节点的先后次序一致。

例如：链表9->0->4->5->1，pivot=3。调整后的链表是0->1->9->4->5。在满足原问题要求的同时，左部分节点从左到右为0、1。在原链表中也是先出现0后出现1；中间部分在本例中为空，不做讨论；右部分节点从左到右为9、4、5。在原链表中也是先出现9，然后出现4，最后出现5。

（2）    如果链表长度为N，时间复杂度请达到O(N)，额外空间复杂度请达到O(1)。



## 2.9 复制含有随机指针节点的链表

【题目】一种特殊的链表节点类描述如下：

```cpp
class Node {
public:
   Node(int data) {
       this->value = data;
   }

private:
   int value;
   Node *next;
   Node *rand;
};
```

Node类中的value是节点的值，next指针和正常单链表中next指针的意义一样，都指向下一个节点，rand指针是Node类中新增的指针，这个指针可能指向链表中的任意一个节点，也可能指向null。

给定一个由Node节点类型组成的无环单链表的头节点head，请实现一个函数完成这个链表中所有结构的复制，并返回复制的新链表的头节点。例如：链表1->2->3->null，假设1的rand指针指向3，2的rand指针指向null，3的rand指针指向1。复制后的链表应该也是这种结构，比如1’->2’->3’->null，1’的rand指针指向3’，2’的rand指针指向null，3’的rand指针指向1’，最后返回1’。

【进阶】不使用额外的数据结构，只用有限几个变量，且在时间复杂度为O(N)内完成原问题要实现的函数。



## 2.10   两个单链表生成相加链表

【题目】假设链表中每一个阶段的值都在0~9之间，你们链表整体就可以代表一个整数。例如：9->3->7，可以代表937。给定两个这种链表的头节点head1和head2，请生成代表两个整数相加值的结果链表。例如：链表1为9->3->7，链表2为6->3，最后生成新的结果链表为1->0->0->0。



## 2.11   两个单链表相交的一系列问题

【题目】在本题中，单链表可能有环，也可能无环。给定两个单链表的头节点head1和head2，这两个链表可能相交，也可能不相交。请实现一个函数，如果两个链表相交，请返回相交的第一个节点；如果不相交，返回null即可。

【要求】如果链表1的长度为N，链表2的长度为M，时间复杂度请达到O(N+M)，额外的空间复杂度请达到O(1)。



## 2.12   将单链表的每K个节点之间逆序

【题目】给定一个单链表的头节点head，实现一个调整单链表的函数，使得每K个节点之间逆序。如果最后不够K个节点一组，则不调整最后几个节点。

例如：链表1->2->3->4->5->6->7->8->null，K=3。

调整后为：3->2->1->6->5->4->7->8->null。其中7、8不调整，因为不够一组。



## 2.13   删除无序单链表中重复出现的节点

【题目】给定一个无序单链表的头节点head，删除其中值重复出现的节点。

例如：1->2->3->4->4->2->1->1->null，删除值重复的节点之后为1->2->3->4->null。

请按以下要求实现两种方法。

方法1：如果链表长度为N，时间复杂度达到O(N)。

方法2：额外空间复杂度为O(1)。



## 2.14   在单链表中删除指定值的节点

【题目】给定一个链表的头节点head和一个整数num，请实现函数将值为num的节点全部删除。

例如，链表为1->2->3->4->null，num=3，链表调整后为：1->2->4->null。



## 2.15   将搜索二叉树转换成双向链表

【题目】对二叉树的节点来说，有本身的值域，有指向左孩子节点和右孩子节点的两个指针；对双向链表的节点来说，有本身的值域，有指向上一个节点和下一个节点的指针。在结构上，两种结构有相似性，现在有一棵搜索二叉树，请将其转换成一个有序的双向链表。

例如：节点定义为：

```cpp
class Node {
public:
   Node(int data) {
       this->value = data;
   }

private:
   int value;
   Node *left;
   Node *right;
};
```

一棵搜索二叉树如图所示。

这棵搜索二叉树转换后的双向链表从头到尾依次是1~9。对每一个节点来说，原来的right指针等价于转换后的next指针，原来的left指针的等价于转换后的last指针，最后返回转换后的双向链表的头节点。



## 2.16   单链表的选择排序

【题目】给定一个无序单链表的头节点head，实现单链表的选择排序。

【要求】额外的空间复杂度为O(1)



## 2.17   一种怪异的节点删除方式

【题目】链表节点值为int型，给定一个链表中的节点node，但不给定整个链表的头节点。如何在链表中删除node？请实现这个函数，并分析这样做会出现哪些问题？

【要求】时间复杂度为O(1)



## 2.18   向有序的环形单链表中插入新节点

【题目】一个环形单链表从头节点head开始不降序，同时由最后的节点指回头节点。给定这样一个环形单链表的头节点head和一个整数num，请生产节点值为num的新节点，并插入到这个环形链表中，保证调整后的链表依然有序。



## 2.19   合并两个有序的单链表

【题目】给定两个有序单链表的头节点head1和head2，请合并两个有序链表，合并后的链表依然有序，并返回合并后的链表头节点。

例如：

0->2->3->7->null

1->3->5->7->9->null

合并后的链表为：

0->1->2->3->3->5->7->7->9->null



## 2.20   按照左右半区的方式重新组合单链表

【题目】给定一个单链表的头节点head，链表长度为N，如果N为偶数，那么前N/2个节点算作左半区，后N/2个节点算作右半区；如果N为奇数，那么前N/2个节点算作左半区，后N/2+1个节点算作右半区。左半区从左到右依次记作L1->L2->… …，右半区从左到右依次记作R1->R2->… …，请将链表调整成L1->R1->L2->R2->… …的形式。

例如：

1->null，调整为1->null

1->2->null，调整为1->2->null

1->2->3->null，调整为1->2->3->null

1->2->3->4->null，调整为1->3->2->4->null

1->2->3->4->5->null，调整为1->3->2->4->5->null

1->2->3->4->5->6->null，调整为1->4->2->5->3->6->null









# 第三章 二叉树问题

本章共23题



## 3.1.    分别用递归和非递归的方式实现二叉树先序、中序和后序遍历

【题目】用递归和非递归的方式，分布实现二叉树先序、中序和后序打印所有的节点。我们约定：先序遍历顺序为根、左、右；中序遍历顺序为左、根、右；后序遍历顺序为：左、右、根。



## 3.2.    二叉树的最小深度

【题目】给定一个二叉树的头节点head，求这颗二叉树的最小深度。例如下图所示的二叉树，答案为4.

【进阶】请将解法时间复杂度优化到O(N)，额外空间复杂度O(1)。

![img](../../_static/CodeInterviewGuide/clip_image_0302.png)



## 3.3.    如何较为直观地打印二叉树

【题目】二叉树可以用三种常用的遍历结果来描述其结构，但是不够直观，尤其是二叉树中有重复值的时候，仅通过三种遍历的结果来构造二叉树的真实结构更是难上加难，有时则根本不可能。给定一棵二叉树的头节点head，已知二叉树节点值的类型为32为整型，请实现一个打印二叉树结构的函数，可以直观地展示树的结构，也便于画出真实的结构。



## 3.4.    二叉树的序列化和反序列化

【题目】二叉树被记录成文件的过程叫做二叉树的序列化，通过文件内容来重建原来二叉树的过程叫做二叉树的反序列化。给定一棵二叉树的头节点head，已知二叉树节点值的类型为32为整型。请设计一种二叉树的序列化和反序列化的方案，并用代码实现。



## 3.5.    遍历二叉树的神级方法

【题目】给定一棵二叉树的头节点head，完成二叉树的先序、中序和后序遍历。如果二叉树的节点数为N，则要求时间复杂度为O(N)，额外的空间复杂度为O(1)。【2020.5.25日之前看到本题】



## 3.6.    在二叉树中找到累加值为指定值的最长路径长度

【题目】给定一棵二叉树的头节点和一个32位整数sum，二叉树节点值类型为整型，求累加和为sum的最长路径长度。路径是指从某个节点往下，每次最多选择一个孩子节点或者不选所形成的节点链。

例如,二叉树如图所示。

![img](../../_static/CodeInterviewGuide/clip_image_0306.png)

如果sum=6，那么累加和为6的最长路径为：-3,3,0,6，所以返回4.

如果sum=-9，那么累加和为-9的最长路径为：-9，所以返回1.

注：本题不用考虑节点值相加可能溢出的情况。



## 3.7.    找到二叉树中最大搜索二叉子树

【题目】给定一棵二叉树的头节点head，已知其中所有节点的值都不一样，找到含有节点最多的搜索二叉子树，并返回这棵树的头节点。

例如，二叉树如下图左所示，那么这棵树中的最大搜索二叉子树如下图右所示。

![img](../../_static/CodeInterviewGuide/clip_image_0307.png)

【要求】如果节点数为N，则要求时间复杂度为O(N)，额外空间复杂度为O(h)，h为二叉树的高度。



## 3.8.    找到二叉树中符合搜索二叉树条件的最大拓扑结构

【题目】给定一棵二叉树的头节点head，已知所有节点的值都不一样，返回其中最大的且符合搜索二叉树条件的最大拓扑结构的大小。

例如，二叉树如下图左所示，其中最大的且符合搜索二叉树条件的最大拓扑结构如下图右所示，这个拓扑结构的节点数为8，所以返回8.

![img](../../_static/CodeInterviewGuide/clip_image_0308.png)

二叉树的按层打印与ZigZag打印

【题目】给定一棵二叉树的头节点head，分别实现按层和ZigZag打印二叉树的函数。例如二叉树如图所示。

![img](../../_static/CodeInterviewGuide/clip_image_0308_01.png)

那么按层打印时，输出格式必须如下：

```bash
Level 1: 1

Level 2: 2 3

Level 3: 4 5 6

Level 4: 7 8
```

ZigZag打印时，输出格式必须如下：

```cpp
Level 1 from left to right: 1

Level 2 from right to left: 3 2

Level 3 from left to right: 4 5 6

Level 4 from right to left: 8 7
```



## 3.9.    调整搜索二叉树中两个错误的节点

【题目】一棵二叉树原本是搜索二叉树，但是其中的两个节点调换了位置，使得这棵二叉树不再是搜索二叉树，请找到这两个节点并返回。已知二叉树中所有节点的值都不一样，给定二叉树的头节点head，返回一个长度为2的二叉树节点类型数组errs，errs[0]表示一个错误节点，errs[1]表示另一个错误节点。

【进阶】如果在原问题中得到了这两个错误节点，我们当然可以通过交换两个节点的节点值的方式让整棵二叉树重新成为搜索二叉树。但现在要求你不能这么做，而是在结构上完全交换两个节点的位置，请实现调整函数。



## 3.10.   判断t1树是否包含t2树全部的拓扑结构

【题目】给定彼此独立的两棵树头节点，分别为t1和t2，判断t1树是否包含t2树全部的拓扑结构。例如下图左的t1树包含图右t2树全部的拓扑结构，所以返回true。

![img](../../_static/CodeInterviewGuide/clip_image_0310.png)



## 3.11.   判断t1树中是否有与t2树拓扑结构完全相同的子树

【题目】给定彼此独立的两棵树头节点，分别为t1和t2，判断t1树中是否有与t2树拓扑结构完全相同的子树。

例如，下图左的t1树有与图右t2树拓扑结构完全相同的子树，所以返回true。

![img](../../_static/CodeInterviewGuide/clip_image_0311.png)

再比如，下图左的t1树没有与图右t2树拓扑结构完全相同的子树，所以返回true。

![img](../../_static/CodeInterviewGuide/clip_image_0311_01.png)



## 3.12.   判断二叉树是否为平衡二叉树

【题目】平衡二叉树的性质为：要么是一棵空树，要么任何一个节点的左右子树高度差的绝对值不超过1。给定一棵二叉树的头节点head，判断这棵二叉树是否为平衡二叉树。

【要求】如果二叉树的节点数为N，要求时间复杂度为O(N)。



## 3.13.   根据后序数组重建搜索二叉树

【题目】给定一个整型数组arr，已知其中没有重复值，判断arr是否可能是节点值类型为整型的搜索二叉树后序遍历的结果。

【进阶】如果整型数组arr中没有重复值，且已知是一棵搜索二叉树后序遍历的结果，通过数组arr重构二叉树。



## 3.14.   判断一棵二叉树是否为搜索二叉树和完全二叉树

【题目】给定二叉树的一个头节点head，已知其中没有重复值的节点，实现两个函数分别判断这棵二叉树是否为搜索二叉树和完全二叉树。



## 3.15.   通过有序数组生成平衡搜索二叉树

【题目】给定一个有序数组sortArr，已知其中没有重复值，用这个有序数组生成一个平衡搜索二叉树，并且该搜索二叉树中序遍历的结果与sortArr一致。



## 3.16.   在二叉树中找到一个节点的后继节点

现在有一种新型的二叉树节点类型如下：

```cpp
class Node {
public:
	Node(int data) {
		this->value = data;
	}

private:
	int value;
	Node *left;
	Node *right;
	Node *parent;
};
```



该结构比普通二叉树结构多了一个指向父节点的指针parent。假设有一颗Node类型的节点组成的二叉树，树中每个节点的parent指针都正确地指向自己的父节点，头节点的parent指向null。只给出一个在二叉树中的某个节点node，请实现返回node的后继节点的函数。在二叉树的中序遍历的结果中，node的下一个节点叫做node的后继节点。

如图所示的二叉树

![img](../../_static/CodeInterviewGuide/clip_image_0316.png)

中序遍历结果为：1,2,3,4,5,6,7,8,9,10

所以节点1的后继节点为2，节点2的后继节点为3… … ，节点10的后继节点为null。



## 3.17.   在二叉树中找到两个节点的最近公共祖先

【题目】给定一棵二叉树的头节点head，以及这棵树中的两个节点o1和o2，请返回o1和o2的最近公共祖先节点。例如如下图的二叉树，

![img](../../_static/CodeInterviewGuide/clip_image_0317.png)

节点4和节点5的最近公共祖先为节点2，节点5和节点2的最近公共祖先节点为节点2，节点6和节点8的最近公共祖先节点为节点3，节点5和节点8的最近公共祖先节点为节点1。

【进阶】如果查询两个节点最近公共祖先的操作十分频繁，想让单次查询的查询时间减少。

【再进阶】给定二叉树的头节点head，同时给定所有想要进行的查询。二叉树的节点数量为N，查询条数为M，请在时间复杂度为O(N+M)内返回所有查询的结果。



## 3.18.   Tarjan算法与并查集进阶二叉树节点间最近公共祖先的批量查询问题

【题目】如下的Node类是标准的二叉树节点结构：

```cpp
class Node {
public:
	Node(int data) {
		this->value = data;
    }

private:
	int value;
	Node *left;
	Node *right;
};
```

再定义Query类如下：

```cpp
class Query {
public:
    Node(Node *o1, Node *o2) {
		this->o1 = o1;
        this->o2 = o2;
	}
    
private:
	Node *o1;
	Node *o2;
};
```

一个Query类的实例表示一条查询语句，表示想要查询o1节点和o2节点的最近公共祖先节点。

给定一棵二叉树的头节点head，并给定所有的查询语句，即一个Query类型的数组Query ques[]，请返回Node类型的数组Node[] ans，ans[i]代表ques[i]这条查询语句的答案，即ques[i].o1和ques[i].o2的最近公共祖先。

【要求】如果二叉树的节点数为N，查询语句的条数为M，整个处理过程的时间复杂度要求达到O(N+M)



## 3.19.   二叉树节点间的最大距离问题

【题目】从二叉树的节点A出发，可以向上走或向下走，但沿途的节点只能经过一次，当到达节点B时，路径上的节点数叫做A到B的距离。

比如图示的二叉树，节点4和节点2的距离为2，节点5和节点6的距离为5.给定一棵二叉树的头节点head，求整棵树上节点间的最大距离。

![img](../../_static/CodeInterviewGuide/clip_image_0319.png)

【要求】如果二叉树的节点数为N，时间复杂度要求为O(N)。



## 3.20.   派对的最大快乐

【题目】员工的消息如下：

```cpp
class Employee {
public:
	Node(int data) {
		this->value = data;
	}

private:
	int happy;
	std::list<Employee> subordinates;
};
```



公司的每个员工都符合Employee类的描述。整个公司的人员结构可以看做是一棵标准的、没有环的多叉树。树的头节点是公司的唯一老板，除老板外，每个员工都有唯一的上级。叶节点是没有任何下属的基层员工(subordinates为空)，除了基层员工外，每个员工都有一个或多个直接下级。

这个公司现在要举办派对，你可以决定哪些员工来，哪些员工不来。但是要遵循如下规则：

（1）  如果某个员工来了，那么这个员工的所有直接下级都不能来

（2）  派对的整体快乐值是所有到场的员工快乐值的累加和

（3）  你的目标是让派对的整体快乐值尽量大

给定一个头节点boss，请返回派对的最大快乐值

【要求】如果以boss为头节点的整棵树有N个节点，请做到时间复杂度为O(N)。



## 3.21.   请通过先序和中序数组生成后序数组

【题目】已知一棵二叉树的所有节点值都不同，给定这棵树正确的先序和中序数组，不要重建整棵树，而是通过这两个数组直接生成正确的后序数组。



## 3.22.   统计和生成所有不同的二叉树

【题目】给定一个整数N，如果N<1，代表空树结构，否则代表中序遍历数组的结果为{1,2,3,…,N}。请返回可能的二叉树结构有多少种？

例如，N=-1时，代表空树结构，返回1；N=2时，满足中序遍历为{1,2}的二叉树结构只有图示两种结构，所以返回结果为2.

![img](../../_static/CodeInterviewGuide/clip_image_0322.png)

【进阶】N的含义不变，假设可能的二叉树结构有M种，请返回M个二叉树的头节点，每一棵二叉树代表一种可能的结构。



## 3.23.   统计完全二叉树的节点数

【题目】给定一棵完全二叉树的头节点head，请返回这棵树的节点个数。

【要求】如果完全二叉树的节点数为N，请实现时间复杂度低于O(N)的解法。

