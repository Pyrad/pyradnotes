# The Code Interview Guide

本章总共11题



# 第一章 栈和队列



## 1.1  设计一个有getMin功能的栈

【题目】实现一个特殊的栈，在实现栈的基本功能的基础上，再实现返回栈中最小元素的操作。

【要求】

【1】  `pop`，`push`，`getMin`操作的时间复杂度O(1)

【2】  设计的栈类型可以使用现成的栈结构



## 1.2  由两个栈组成的队列

【题目】编写一个类，用两个栈实现队列，支持队列的基本操作（`push`，`pop`，`front`，`back`）



## 1.3  如何仅用递归函数和栈操作逆序一个栈

一个栈依次压入1,2,3,4,5，那么从栈顶到栈底就依次为5,4,3,2,1。将这个站逆转后，从栈顶到栈底依次是1,2,3,4,5，即实现栈中元素的逆序，但是仅能用递归函数来实现，不能使用其他数据结构。



## 1.4  猫狗队列

宠物，狗和猫的类如下：

```cpp
class Pet {
public:
   Pet(std::string type) {
       this->type = type;
   }
   std::string getPetType() {
        return this->type;
   }

private:
   std::string type;
};


class Dog : public class Pet {
public:
	Dog() : Pet("dog") {}
};

class Cat : public class Pet {
public:
   Cat() : Pet("cat") {}
};
```



实现一种狗猫队列，要求如下：

（1）  用户可以调用`add`方法将cat类或dog类的实例放入队列中

（2）  用户可以调用`pollAll`方法，将队列中的所有实例按照进队列的先后顺序依次弹出

（3）  用户可以调用`pollDog`方法，将队列中Dog类的所有实例按照进队列的先后顺序依次弹出

（4）  用户可以调用`pollCat`方法，将队列中Cat类的所有实例按照进队列的先后顺序依次弹出

（5）  用户可以调用`isEmpty`方法，检查队列中是否还有Dog类或者Cat类的实例

（6）  用户可以调用`isDogEmpty`方法，检查队列中是否还有Dog类的实例

（7）  用户可以调用`isCatEmpty`方法，检查队列中是否还有Cat类的实例



## 1.5  用一个栈实现另一个站的排序

【题目】一个栈中的元素为整型，现在想将该栈从顶到底按照从大到小的顺序排序，只允许申请一个栈。除此之外，可以申请新的变量，但不能申请额外的数据结构。然后完成排序？



## 1.6  用栈求解汉诺塔问题

【题目】汉诺塔问题比较经典，这里修改一下游戏规则：现在限制不能直接从最左侧的塔移动到最右侧，也不能直接从最右侧移动到最左侧，而是必须经过中间的塔。求当有N层塔时，打印最优移动过程和最优移动步数。

例如，当塔为两层时，最上层的塔记为1，最下层的塔记为2，则打印：

```bash
Move 1 from left to mid
Move 1 from mid to right
Move 2 from left to mid

Move 1 from right to mid
Move 1 from mid to left
Move 2 from mid to right
Move 1 from left to mid
Move 1 from mid to right

It will move 8 steps
```



【要求】方法一：使用递归的方法；方法二：使用非递归的方法，用栈来模拟汉诺塔的三个塔。



## 1.7  生成窗口最大值数组

【题目】有一个整型数组arr和一个大小为w的窗口从数组的最左边滑动到最右边，窗口每次向右滑动一个位置。

例如：数组为[4,3,5,4,3,3,6,7]，窗口大小为3时：

[4 3 5] 4 3 3 6 7 窗口中最大值为5

4 [3 5 4] 3 3 6 7 窗口中最大值为5

4 3 [5 4 3] 3 6 7 窗口中最大值为5

4 3 5 [4 3 3] 6 7 窗口中最大值为4

4 3 5 4 [3 3 6] 7 窗口中最大值为6

4 3 5 4 3 [3 6 7] 窗口中最大值为7

如果数组长度为n，窗口大小为w，则总共产生n-w+1个窗口的最大值。

请实现一个函数：

输入：整型数组arr，窗口大小为w。

输出：一个长度为n-w+1的数组res，res[i]表示每一种窗口状态下的最大值。

以本题为例，结果应该返回数组[5,5,5,4,6,7]



## 1.8  单调栈结构

【题目】给定一个不含有重复值的数组arr，找到每一个位置i左边和右边距离i位置最近且值比arr[i]小的位置。返回所有位置相应的信息。

【举例】arr = {3,4,1,5,6,2,7}，返回如下二维数组作为结果：

```bash
{
	{-1,2}，
	{0,2}，
	{-1,-1},
	{2,5},
	{3,5},
	{2,-1},
	{5,-1},
}
```

-1表示不存在。所以上面的结果表在arr中，0位置左边和右边距离0位置最近而且值比arr[0]小的位置是-1和2；1位置左边和右边距离1位置最近而且值比arr[1]小的位置是0和2；2位置左边和右边距离2位置最近而且值比arr[2]小的位置是-1和-1；……

【进阶问题】给定一个可能含有重复值的数组arr，找到每一个位置i左边和右边距离i位置最近且值比arr[i]小的位置。返回所有位置相应的信息。

【要求】如果arr长度为N，实现原问题和进阶问题的解法，时间复杂度都达到O(N)。



## 1.9  求最大子矩阵的大小

【题目】给定一个整型矩阵map，其中的值只有0和1两种，求其中全是1的所有矩形区域中，最大的矩形区域为1的数量。

例如：

1 1 1 0

其中，最大的矩形区域有3个，所有返回3。

再比如：

1 0 1 1

1 1 1 1

1 1 1 0

其中，最大的矩形区域有6个，所有返回6。



## 1.10 最大值减去最小值小于或等于num的子数组数量

给定数组arr和整数num，返回共有多少个子数组满足如下情况：

max{arr[i..j]} – min{arr[i..j]} <= num

max{arr[i..j]}是子数组arr[i..j]中的最大值，min{arr[i..j]}是子数组arr[i..j]中的最小值



## 1.11 可见的山峰对数量

一个不含有负数的数组可以代表一圈环形山，每个位置的值代表山的高度。比如{3,1,2,4,5}, {4,5,3,1,2}, {1,2,4,5,4}都代表同样的环形山。3à1à2à4à5à3方向是next方向（顺时针），3à5à4à2à1à3方向是last方向（逆时针）。

山峰A和山峰B能够相互看见的条件为：

\1.   如果A和B是同一座山，认为不能互相看见。

\2.   如果A和B是不同的山，并且在环中相邻，认为可以互相看见。

\3.   如果A和B是不同的山，并且在环中不相邻，假设两座山高度最小值为min。如果A通过next方向到B的途中没有高度比min大的山峰，或者A通过last方向到B的途中没有高度比min大的山峰，认为A和B可以互相看见。

给定一个不含有负数且没有重复值的数组，返回共有多少对山峰能够相互看见？

【进阶问题】给定一个不含有负数但可能有重复值的数组，返回共有多少对山峰能够相互看见？
