# Computational Geometry

**Algorithms and Applications, Third Edition**



## About the book

**Third Edition (March 2008)**

**[Mark de Berg](http://www.win.tue.nl/~mdberg/),** TU Eindhoven (the Netherlands)
**[Otfried Cheong](http://tclab.kaist.ac.kr/~otfried/),** KAIST (Korea)
**[Marc van Kreveld](http://www.cs.uu.nl/staff/marc.html), [Mark Overmars](http://www.cs.uu.nl/staff/markov.html),** Utrecht University (the Netherlands)



[Website URL](http://www.cs.uu.nl/geobook/)

Published by Springer

[Errata Page for 1st Edition](http://www.cs.uu.nl/geobook/errata1.html)

[Errata Page for 2nd Edition](http://www.cs.uu.nl/geobook/buglist2a.pdf)



## Resources

[*Handbook of Discrete and Computational Geometry, 3rd Edition, Online Page*](https://www.csun.edu/~ctoth/Handbook/HDCG3.html)





## Words

**asymptote** */ˈæsɪmˌtoʊt/* *n.* [数] 渐近线

**asymptotically**  */,æsimp'tɔtikli,-kəli/* *adj.* 渐近线的

**planar** */ˈpleɪnər/* *adj.* 平面的；二维的；平坦的

**polygonal** */pəˈlɪɡənl/* *adj.* [数] 多边形的；[数] 多角形的

**lexicographic** */ˌleksɪkəˈɡræfɪk/* *adj.* 词典编辑的；字典式的

**dent** */dent/* *v.* 使产生凹痕；损害，削弱；*n.* 凹痕；削减

**clutter** */ˈklʌtər/* *v.* 乱堆，塞满；使（脑子里）塞满（乱七八糟的事）；*n.* 杂乱的东西；杂乱

**radiosity** */ˌreɪdɪˈəʊsɪtɪ/* *n.* 光能传递；热辐射

**kinematic** */ˌkɪnəˈmætɪk/* *adj.* [力] 运动学上的，[力] 运动学的

**vegetation** */ˌvedʒəˈteɪʃn/* *n.* （总称）植物，植被；（植物的）生长；呆板单调的生活

**excavation** */ˌekskəˈveɪʃ(ə)n/* *n.* （对古物的）发掘，挖掘；发掘现场； 挖洞，开凿

**interpolate** */ɪnˈtɜːrpəleɪt/* *vt.* 篡改；插入新语句；*vi.* 插入；篡改

**interpolating** */ɪnˈtɜːrpəleɪtɪŋ/* *n.* 插值；内插；*v.* 窜改；加入（额外的事）

**thematic** */θɪˈmætɪk/* *adj.* 主题的，主旋律的；题目的；语干的

**precipitation** */prɪˌsɪpɪˈteɪʃ(ə)n/* *n.* 降水（如雨，雪，冰雹）；沉淀，淀析；仓促，鲁莽，轻率；坠落

**grizzly** */ˈɡrɪzli/* *adj.* 灰色的；*n.* 灰熊

**lemma** */ˈlemə/* *n.* 引理；辅助定理；论点；膜

**recap** */ˈriːkæp/* *v.* 扼要重述，摘要说明；翻新胎面；*n.* 扼要的重述，概述；翻新的轮胎

**treat** */triːt/* *v.* 处理，探讨，论述；

**deciduous** */dɪˈsɪdʒuəs/* *adj.* 落叶性的，脱落性的；非永久性的

**cyclic** */ˈsaɪklɪk/* *adj.* 环的；循环的；周期的

**corollary** */ˈkɔːrəleri/* *n.* 推论；必然的结果

**paradigm** */ˈpærədaɪm/* *n.* 典范，范例；样板，范式；词形变化表；纵聚合关系语言项

**triangulation** */traɪˌæŋɡjuˈleɪʃn/* *n.* [测] 三角测量；三角形划分

**overkill** */ˈoʊvərkɪl/* *n*. 过犹不及

**dual graph** 【数】对偶图

**prong** */prɔːŋ/* *n.* 尖齿；方向；（俚语）阴茎；耙子；（多种工具的）尖头；（作战）分支；*v.* 刺，贯穿

**combinatorial**  */*kɒmˌbaɪnəˈtɔːrɪəl*/* *adj.* 组合的

**monotone** */*ˈmɒnətəʊn*/* *n.* 单调；单音调；*adj.* 单调的







## Usage

thought experiment

an elastic rubber band 橡皮筋

direct the line through *p* and *q*

to this end 为了这个目的（**formal** **:** as a way of dealing with or doing something）

rule out 排除，除去

windy river 弯曲的河流（不是多风的河流）

coinciding point 共点

in a sense 某种意义上

incident to 由...产生（这里incident是 *adj.*）

hold for 适用



> Define the *y*-interval of a segment to be its orthogonal projection onto the *y*-axis.
>
> 把一条线段在 *y* 轴上的正交投影，叫做它的 *y*-interval



> they are far apart in the y-direction
>
> 它们在y方向上相距足够远



> We denote the *event queue* by Q
>
> 我们把event queue记作**Q**



> This horizontal sweeping line is sloping just a tiny bit upward
>
> 这条横向的扫描线翘起来一点点



> We need an operation that removes the next event that will occur from Q, and returns it so that **it can be treated**.
>
> 需要一个从队列Q里面删除下个event（point）的操作，并且返回它，以便（对它进行）处理。



> Therefore we model a gallery as a **polygonal region** in the plane.
>
> 我们把画廊当做一个二维平面上的多边形



## Names

- Graham’s scan
- output-sensitive algorithm
- planar graph
- planar subdivisions
- Art Gallery Problem (combinatorial geometry)
- dual graph
- Monotone polygon









## Maths

$e'$ ：$e$ prime（或 $e$ dash）

$e''$ ：$e$ double prime（或 $e$ double dash）



## Contents

- Preface
- 1 Computational Geometry (Introduction)
- 2 Line Segment Intersection (Thematic Map Overlay)
- 3 Polygon Triangulation (Guarding an Art Gallery)
- 4 Linear Programming (Manufacturing with Molds)
- 5 Orthogonal Range Searching (Querying a Database)
- 6 Point Location (Knowing Where You Are)
- 7 Voronoi Diagrams (The Post Office Problem)
- 8 Arrangements and Duality (Supersampling in Ray Tracing)
- 9 Delaunay Triangulations (Height Interpolation)
- 10 More Geometric Data Structures (Windowing)
- 11 Convex Hulls (Mixing Things)
- 12 Binary Space Partitions (The Painter’s Algorithm)
- 13 Robot Motion Planning (Getting Where You Want to Be)
- 14 Quadtrees (Non-Uniform Mesh Generation)
- 15 Visibility Graphs (Finding the Shortest Route)
- 16 Simplex Range Searching (Windowing Revisited)
- Bibliography
- Index



## Preface

序言要点

- 计算几何兴起与20世纪70年代（1970s），应用于计算机图形（CG）、地理信息系统（GIS）、机器人（robotics）等领域。
- 本书每章节基本独立，但初学者可以按顺序阅读前10章。
- 每章节只举例了容易理解和实现的算法（解决方案），并不是所有，而且提供的是高层次的论述，并不深入每个细节。
- 带星号（`*`）的章节作为扩展阅读，以及叫做 *Notes and Comments*的小节，可以通过其了解更多。
- 不需要应用领域的知识，只需要基本的数据结构和算法知识储备。
- 有网页可以找到[Errata Page](http://www.cs.uu.nl/geobook/)以及其他可用资源。



## 1 Computational Geometry - Introduction

校园中寻找最近电话亭（*Voronoi diagram*，第7章）

避障最短路径（*motion planning*，第13,15章）

多张地图定位问题（*overlay map*，第2章）

实际的应用

- Robotics
- Computer graphics
- CAD/CAM
- Geographic Information System



### 1.1 An Example: Convex Hulls

好的几何算法问题解决方案，本质上有两方面

- 理解几何问题的特性
- 对算法和数据结构的合理使用

本节举例，介绍了两种计算二维平面上凸体的轮廓的算法（二维平面凸体，planar convex hulls）



#### 1.1.1 第一种算法

第一种算法是时间复杂度较高的算法，文中称为 ***SlowConvexHull*** 算法。

**输入**：平面上点的集合 ***P***。

**输出**：一个点的序列 ***L***，表示点集合 ***P*** 的Convex Hull，点序是**顺时针**方向。

**算法简述**：

从集合 ***P*** 中取任意不同两点 *p* 和 *q*，组成一有向线段 *p* -> *q*，检查集合 ***P*** 中剩余的任意一点 *r*，如果任意一点 *r* 都位于有向线段 *p* -> *q* 的右侧，说明有向线段 *p* -> *q* 就是最终轮廓上的其中一条线段，将其加入集合 ***E*** 中。

穷举集合 ***P*** 中这样两个点 *p* 和 *q* 的组合，重复上述检查，直至最终遍历完成，得到一个线段集合 ***E***。

最后，从集合 ***E*** 中找出依次连接的线段，并组成一个点列表，按照**顺时针**方向排序。

**算法复杂度**：O(n^3)



对于伪代码中的几个的说明

- 诸如判断一个点在一条直线（线段）的左边或右边的操作，默认已经有现成的实现可以使用
- 从集合 ***E*** 中找出依次连接的有向线段的步骤是，首先从 ***E*** 中取任一有向线段 *e1*，以其头点（即 *p* -> *q* 线段的 *q* 点）为目标，从集合 ***E*** 中找出第二条有向线段 *e2*，其尾点（即 *p* -> *q* 线段的 *p* 点）为 *e1* 的头点，然后再以 *e2* 的头点搜索下一条有向线段，直到搜索到的这些线段 *e1*,  *e2*, *e3*, ..., *eN* 构成一条闭合的折线段。
- 关于算法复杂度是O(n^3)。从 *n* 个点中取两个点的组合是 *n!/ 2! (n-2)! = n(n-1)*，所以是O(n^2)，对每一条有向线段，查看剩余 *n-2* 个点是否在其右侧，这样时间复杂度就达到了O(n^3)。最后一步依次找出有向线段并按顺序连接，时间复杂度是O(n^2)，所以最终时间复杂度就是O(n^3)。



关于 ***degenerate case*** 或者叫做 ***degeneracy***

在判断一个点 *k* 是否在有向线段 *p* -> *q* 右侧时，点 *k* 是可能落在有向线段 *p* -> *q* 上的，针对这种退化情况，可以把它也当做是在有向线段右侧的一种（退化）情况。



关于 ***rounding error*** 导致的程序健壮性问题（robustness）

在实际情况中，因为使用的是浮点数计算，那么仍然是在判断一个点 *k* 是否在有向线段 *p* -> *q* 右侧时，可能产生微小的误差（rounding errors），导致最终计算出来的convex hull的点集合 ***E*** 有三种情况：

1. 要么不是真正意义上的convex hull（但仍然是非常接近实际情况的）
2. 要么最终的集合 ***E*** 中的有向线段不是一个闭合的折线段
3. 要么最终的集合 ***E*** 中的有向线段除了可以组成一个闭合的折线段外，还有额外剩余的几条有向线段

正是由于这种robust的问题，迫使我们需要寻找一种更为健壮和正确的算法。



#### 1.1.2 第二种算法

第二种算法是时间复杂度比第一种算法低，采用了所谓的 *incremental algorithm* 的方法，文中名为ConvexHull算法。

这种算法的总体思路是，将所有的点按照 *x* 坐标由大到小排序为 *p1*, *p2*, *p3*, ..., *pN*，因为前提是凸多边形，所以先按照从左向右的方向，找到这convex hull的上半部分边界 *upper hull*，即 *p1*, *u0*, *u1*, ..., *pN*（其中*u0*, *u1*, ... 都是集合中的点），再找到convex hull的下半部分边界 *lower hull*，即*p1*, *v0*, *v1*, ..., *pN*（其中*v0*, *v1*, ... 也都是集合中的点）。

这个所谓的 *incremental algorithm* 方法的关键步骤在于，如何在向已有的但不完整的*upper/lower hull* 添加一个点之后，更新这个不完整的*upper/lower hull*，使得其向左或向右延伸一段（最终到达最右或最左的点）。

换句话说，假如现已有*upper hull*的点是 *p1*, *p2*, ..., *p(i-1)*, 如何找到下一个点 *pi*，使得 *p1*, *p2*, ..., *pi* 是最终 *upper hull* 的一部分。

因为我们约定是按照顺时针方向来标记最终的convex hull的，所以，沿着convex hull的边界行走，一定是**“右转”**的。因此，可以按照此方法来确定如何加入上面提到的*pi*点，从而生成一条新的convex hull的一部分。

假设我们现在计算的是 *upper hull*，那么我们遍历的点一定是按照 *x* 坐标有小到大的顺序，那么当加入点 *pi* 时，点 *pi* 的 *x* 坐标就是目前的convex hull 点 *p1*, *p2*, ..., *p(i-1)* 里面 *x* 坐标最大的。

加入点 *pi* 后，此时点列为  *p1*, *p2*, ..., *p(i-1)*, *pi*。此时我们检查最后三个点 *p(i-2)*, *p(i-1)*, *pi*。

- 如果这三个点是**“右转”**的，那么新加入的点 *pi*，就是最终 upper convex hull的一部分（但有可能在加入之后的点以后，继续做调整从而删除点 *pi*）。

- 如果这三个点是**“左转”**的，那么因为目前 *pi* 的 *x* 坐标最大，它就一定是在目前遍历过的convex hull上，所以我们就需要从 *p(i-1)* 开始向后检查，每次删除最后3个点的中间的点（即每次的倒数第二个点），做重新调整。

  先删除 *p(i-1)* 这个点，然后检查此时的最后三个点，*p(i-3)*, *p(i-2)*, *pi*，如果它们组成了**“右转”**的折线，那么本次调整到此结束，然后继续加入下一个点 *p(i+1)*；如果它们组成了**“左转”**的折线，那么就需要再次删除中间点，即*p(i-2)*，然后继续检查时的最后三个点，*p(i-4)*, *p(i-3)*, *pi*，并重复上述步骤，直到最后三个点组成**“右转”**的折线（或者直到剩下最后2个点），本次调整才到此结束，然后继续加入下一个点 *p(i+1)*。

当针对上述两种情况做完调整之后，此时继续加入下一个点 *p(i+1)*，并重复上述步骤，直到加入最右边的点 *pN*，此时就得到了 *upper hull*。

寻找 *lower hull* 的incremental的步骤和上述类似。



第二种算法简述

**（这个算法实际上是Andrew对Graham’s scan的一种改进算法）**

**输入**：平面上点的集合 ***P***。

**输出**：一个点的序列 ***L***，表示点集合 ***P*** 的Convex Hull，点序是**顺时针**方向。

**算法简述**：

- 将集合 *P* 按 *x* 坐标排序为 *p1*, *p2*, ..., *pN*
- 把*p1*, *p2* 放入序列 ***L***，并且 *p1* 是第一个点， *p2* 是第二个点
- 变量 *i*，值从3到N，依次遍历加入序列 ***L1***，每次加入点 *pi*，检查最后三个点是否组成**“右转”**的折线段。如果是，继续遍历下一个值，否则删除当前序列 ***L1*** 的倒数第二个点，并继续检查最后三个点是否组成**“右转”**的折线段，以此类推，直到当前序列 ***L1*** 的最后三个点组成**“右转”**的折线段，才继续遍历下一个 *i* 值。
- 当变量 *i* 遍历完成时，就得到了convex hull的上半部分 upper hull的点序列是 ***L1*** 。
- 把*pN*, *p(N-1)* 放入序列 ***L2***，并且 *pN* 是第一个点， *p(N-1)* 是第二个点
- 变量 *j*，值从N-2到1，依次加入序列 ***L2***，和上面寻找upper hull的办法类似，仍然是确保每加入一点后，调整序列 ***L2***，使得其最后三点组成**“右转”**的折线段，然后才继续遍历下一个 *j* 值。
- 把序列 ***L2*** 的第一个和最后一个点去掉，避免重复点。
- 把序列  ***L1*** 和序列  ***L2*** 合并，即得到最终的点序列 ***L***。

时间复杂度：O(nlogn)



对于该算法的几点说明

- 在排序时，如果 *x* 坐标相同，可以按照 lexicographic 的办法排序，即先按照 *x* 坐标排序，如果 *x* 坐标相同，就再按照 *y* 坐标排序（仅对 *x* 坐标相同的点的情况下）。
- 在上面判断最后三点是否组成**“右转”**的折线段时，如果这三点共线，仍然把这种情况归为**”左转“**的情况，从而触发删除三点里面中间点的操作处理。
- 因为使用的是floating point calculation，并且依然存在rounding error，所以最后的点列表，有一定概率并不是实际上真正的convex hull的点列表（比如有三个点靠的很近以至于是一个左转的折线段，但被计算为右转了），但这种结果是可以接受的。



#### 1.1.3 计算convex hull的时间复杂度

> Theorem 1.1 The convex hull of a set of n points in the plane can be computed in O(nlogn) time.

关于第二种算法正确性的证明，文中采用了数学归纳法。

以upper hull为例，假如现已有点列 {*p1*, *p2*, ..., *p(i-1)*}，准备加入点 *pi*。根据算法，点列{*p1*, *p2*, ..., *p(i-1)*}中最后三点一定是组成**“右转”**的折线段（即除了这些点，到目前最大的点为止，其他点都在这些点的下方）。我们把此时的upper hull点列叫做 old chain。

在加入点 *pi* 之后，按照字典序（lexicographic），最小的点是 *p1*，最大的点是 *pi*，经过调整，此时的upper hull我们叫做new chain（而且new chain的最后一个点一定是*pi*）。

可以断言的是old chain一定是在new chain的下方（有可能点*pi*就是old chain的延伸，但是在算法中，这种共线的情况被当做是左转而被排除掉了）。

按照算法，我们需要证明的是，到目前为止，除了{*p1*, *p2*, ..., *pi*}，所有的点都在new chain的下方。

假如有一个点位于new chain的上方，那么这个点就必须介于 *p(i-1)* 和 *pi*之间，因为在加入 *pi* 之前，所有的点都位于old chain的下方。但这又是矛盾的，因为 *p(i-1)* 和 *pi* 之间没有其它点，因为所有点已经是按照字典序排列过了的。

因此归纳出来，到目前为止，除了{*p1*, *p2*, ..., *pi*}，所有的点都在new chain的下方。算法正确性得到证明。



关于时间复杂度的证明。

对于upper hull，按字典序排序，时间复杂度是O(nlogn)。

for循环是线性的，关键在于其里面用于检查右转折线段和删除中间点的while循环的执行次数。

这个while循环首先可以肯定至少执行一次（检查右转折线段），而额外执行的次数，是为了删除每次得到的序列最后三点的中间点，而因为所有点只会被加入序列一次，所以，每个点最多也只会被删除一次，那么这个for循环里面的while循环执行的上限就是O(n)。

所以，带有while循环的这个for循环，时间复杂度是O(n)，而不是O(n^2)。

因此计算upper hull的时间复杂度就是O(nlogn)。

对于lower hull也是类似的。所以加起来，整个算法的时间复杂度就是O(nlogn)。



### 1.2 Degeneracies and Robustness

提出算法的三个步骤（阶段）

- 首先，排除次要因素的干扰，因为这些因素是细节问题，不影响算法的整体思路。
- 其次，再考虑前面可能出现的退化情况（边界条件，特殊和极端情况等问题），调整算法细节以便处理。
- 最后，实现细节。比如原子操作，如何遍历等等。



比如，在convex hull的算法中，我们可以先假设没有三个共线的点，没有两个点的 *x* 坐标是相同的。

symbolic perturbation schemes指在设计和实现阶段忽略了special case，但在实际应用过程当中算法仍然正确的方法。



在实现细节的阶段，使用实数（浮点数）计算可能导致假设在某种情况下失效的问题，这是算法健壮性的体现。就像前面第二种算法中提到的，最终的output也许不是真正意义上的真实结果，但也是十分接近真实的结果，在这种情况下，需要预期这种情况可能的后果，并避免有次可能产生的crash问题等等。

使用现有的arithmetic library是其中一种办法，如果不能达到我们所需要的要求，就需要自己实现一些特定情况下的处理。



### 1.3 Application Domains

这一节主要介绍了Computational Geometry的几种应用领域，已经每个领域要解决的问题。

- Computer graphics
- Robotics
- Geographic information systems
- CAD/CAM
- Other applications domains （比如 molecular modeling，pattern recognition等）



### 1.4 Notes and Comments

本节主要是对本章内容的一些延伸以及参考书籍资料等出处说明，提到了本章算法的来源，其发展的简要历史，以及相似算法的研究情况。

比如，本章所讨论的convex hull问题是Computational Geometry的经典问题，而本章第二种算法，其实是Graham’s scan算法，是Andrew基于最早的Graham提出的算法的改进。

还有其他的一些算法，时间复杂度也是O(nlogn)。







## 2 Line Segment Intersection - Thematic Map Overlay

引言部分，以旅游为例，讲述了在实际当中，可能需要查看包含不同信息类型的地图，从而找到所需的信息。

在GIS领域中，***layer*** 是指包含某一种信息的地图（map），而需要将多种类型的地图进行交叉引用的合并结果，叫做 ***overlay***。

比如，一个layer（map）只包含城市名的信息，另一个layer（map）只包含河流的信息，还有一个layer（map）只包含了铁路轨道的信息，诸如此类等等。

当查看了城市信息的layer（map）之后，想要得知如何前往，就需要和另一个包含道路信息的layer（map）重叠查看，就是overlay。

GIS中，在overlay上，不同信息有交叉的地方（比如查看河流和道路的重叠情况），有时是一个交叉点，有时是一个交叉的区域。



### 2.1 Line Segment Intersection

本节要解决的问题是，给定二维平面上一个有 *n* 个线段的集合，找出所有的交点。

> given a set S of n closed segments in the plane, report all intersection points among the segments in S.

其中线段的端点碰到其他的线段，也算作交点。

Brute-forced algorithm的时间复杂度是O(n^2)，但实际情况，有可能只有很少的一些线段相交，并不必计算每个线段和其他线段的交点。

即，我们希望算法的复杂度依赖的不仅是输入点的个数，而且也是输出的交点的个数，这样的算法叫做***output-sensitive algorithm***。



可以利用的观察几何结果是：靠的比较近的线段是可能有交点的候选计算对象，而相离较远的线段是不需要计算交点的。

所以思路是，把所有线段向y轴做投影，得到投影线段有重叠的那些线段，就是需要计算交点的候选线段。

为什么没有投影重叠的线段就一定没有交点？这可以通过反证法得出，如果没有投影重叠的线段有交点，那么这个交点的y坐标值一定是介于两个线段的4个端点的y值之间，而这又说明这两条线段是有投影重叠的，因此矛盾，从而的证。



使用到的技术叫做：***plane sweep algorithm***。

***sweep line***：一条水平无限长的假想虚线

***status***：***sweep line***的“状态”指的是和它当前相交的**线段的集合**（**segments**）

***event point***：***sweep line***沿着垂直方向从上向下移动，但不是连续移动的，而是离散的，移动到的这些位置的点，叫做***event point***。这些***event point***，一部分是每条线段的upper end point（y值较大的点）和lower end point（y值较小的点），另一部分是线段之间的交点。

只有当***sweep line***移动到这些***event point***上的时候，算法才做相应的计算或调整，即更新***sweep line***的***status***，并测试线段之间有无交点（如有，就计算交点）。

- 如果***event point***是一条线段的**upper point**，那么这条线段就是和***sweep line***相交，并且应该加入到***status***里面，同时要计算这条segment和***status***里面其他segments的交点（*后面会提到，只计算当前线段相邻的左右两条segments的交点，而不是计算和status里面所有线段的交点*），而且这个交点（如果有）要放入到event point集合的适当位置，以便sweep line依次向下扫描时可以遍历到它。

- 如果***event point***是一条线段的**lower point**，那么这条线段就和***sweep line***不再相交（即变为相离），就应该从status里面删除。而且这也会导致**status**里面原先不直接相邻的两条线段，现在变成了直接相邻了，那就要计算这两条相邻线段之间有无交点（如果有，依然要放入event point集合里面去）

- 如果***event point***是两条线段的**intersection point**（这个intersection point是前面计算得到加入进来的），那么在该点之后，相邻的adjacent neighbor就会发生改变，所以就要测试（计算）这两条segments和它们各自左右相邻的segment的交点。



> Lemma 2.1 Let *si* and *sj* be two non-horizontal segments whose interiors intersect in a single point *p*, and assume there is no third segment passing through *p*. Then there is an event point above *p* where *si* and *sj* become adjacent and are tested for intersection.

因为根据前面遇到的event point是一条线段的upper point时的操作（计算adjacent segment之间的intersection point），这个引理主要想说明，如果两条都不是水平（也不共线）的线段，如果有交点，那么在这个交点的上方，一定有一个event point，在那个event point的时候，这两条线段变成adjacent，并且会被检查（计算）是否有交点。

这里**暂时忽略**了三种特殊情况：两条线段可能共线（重合），可能有水平的情况，以及有第三天线段穿过交点。



所以，简要叙述，***line sweeping algorithm***的大体思路如下

> Let’s briefly recap the overall approach. We imagine moving a horizontal sweep line ℓ downwards over the plane. The sweep line halts at certain event points; in our case these are the endpoints of the segments, which we know beforehand, and the intersection points, which are computed on the fly.
>
> While the sweep line moves we maintain the ordered sequence of segments intersected by it. When the sweep line halts at an event point the sequence of segments changes and, depending on the type of event point, we have to take several actions to update the status and detect intersections.

假设有一条水平扫描线，从上而下移动，每次移动到一个特殊的点（event point）。这样的event point有两种，一种是每条线段的upper point（end point），另一种是某两条线段的交点（intersection point）。前一种在计算之前就已知，而后一种是在扫描线移动过程中计算得出。

当扫描线移动时，维护一个有序的线段列表，列表中的每个线段是和扫描线相交的。当扫描线移动到下一个event point的时候，更新线段列表使其保持有序，同时根据event point的类型，更新状态（它是和扫描线相交的线段集合，每次操作有可能添加或删除一条线段）并检查某两条线段是否有交点。



sweep line遇到三种不同event point时对应的操作

- 如果**event point**是一条线段的**upper point**（end point），就要检查这个upper point所在的线段，和它左右两个相邻的线段是否有交点，如果有交点，那么这个交点就是一个新的event point。当然，upper point所在的线段要放入status中去。

  因为sweep line上方的event point都是已知的或已经计算过的，所以关注的是sweep line下方的交点。

- 如果**event point**是某两条线段的**交点**（intersection point），那么这两条线段在所维护的有序线段列表（status）里面的位置就要交换，同时因为位置变化，它们各自相邻的线段也发生了变化（但只变化了一个，因为另一个仍然是它们自己中的一个），所以也要检查它们和各自新邻近的线段之间是否有交点，如果有并且是之前没有的event point，那么就有发现了一个或两个新的event point。

- 如果**event point**是一条线段的**lower point**（end point），那么这条线段原先左右两条线段就变成了直接相邻的线段，就要检查（计算）这两条线段是否有交点，同样的，如果有，就是新的event point。当然，这个lower point所在的线段要从status里面移除出去。





算法当中需要的两个数据结构

- **event queue**（记作 ***Q***）

  **需要支持删除一个点（event point）的操作**，并返回这个点以便对其处理。

  （如果两个点有相通的y坐标，返回x坐标较小的一个。这个实际上说明，如果一个线段是水平时，当水平的sweep line扫描到这条线段时，upper point是其左边的点，lower point右边的点，即sweep line先遇到的event point是左边的点。）

  **需要支持插入一个点（event point）的操作**，因为新的intersection point是在sweep line移动过程中计算得出。

  同时，允许两个event point是共点的（coincide，比如两条线段的upper point可能是同一个点），但把它们当做是同一个点，所以需要支持查看一个event point是否在***Q***中已经存在。

  根据上述特点，采用平衡二叉搜索树（**Balanced Binary Search Tree**，BST），并定义点（event point） *p* < *q* 的“小于”操作符（`<`）为

  （1）如果 *p* 和 *q* 的y坐标相同，那么 *p* 的x坐标小于*q* 的x坐标

  （2）如果 *p* 和 *q* 的y坐标不相同，那么 *p* 的y坐标小于*q* 的y坐标

  需要删除一个点的操作的原因是，sweep line向下移动时，需要event point的顺序，移动到下一个event point上，而这是二叉树删除一个节点并返回的操作（同时二叉搜索树会重新平衡并排序）

  需要插入一个点的操作的原因是，当sweep line移动到不是intersection point的event point的时候，要计算相邻两条线段之间的intersection point，如果有就要插入BST，所以这是BST的插入节点的操作。

- **status**（记作 ***J***）

  这个所谓的状态，是指当前和水平的sweep line相交的**线段**的**有序**集合。

  对于给定的一条线段，为了计算它和相邻线段的相交情况，它必须是可以动态调整的，即：

  （1）当sweep line遇到一条线段的upper end point的时候，该线段需要放入status，并且需要查看此时它和左右相邻的两条线段的相交情况，如果有交点就需要计算出来，并放入**event queue**里

  （2）当sweep line遇到一条线段的lower end point的时候，该线段需要从status中移除，同时它原先左右相邻的两条线段现在变为直接相邻，那么也要再次查看并计算这两条线段是否有交点，如果有，同样放入**event queue**里

  （3）当sweep line遇到的event point是intersection point的时候，那么就需要交换这两条相交的线段在status中的位置，同时在status中，它们各自分别有一条相邻的线段发生了变化，同样需要再查看并计算交点，如果有交点，同样放入**event queue**里

  同样根据上面的特点，也采用平衡二叉搜索树（**Balanced Binary Search Tree**，BST），但这里的BST里面，只有叶子节点是存储了线段的信息，而树中间的每个节点（interior nodes），存储的都是其左子树里面最右边（叶）节点的线段信息。

  虽然中间的节点也可以存储线段信息，但为了方便陈述算法，所以中间节点都是用来引导寻找最终叶节点的导引信息（values to guide the search），而不是最终的线段数据信息（data item）。



***FindIntersections***算法简述

**输入**：平面上线段的集合 ***S***。

**输出**：交点的集合 ***L***，这些交点都在集合 ***S*** 中的某些线段上，同时每个交点还有其对应的线段信息，表示该交点位于哪（几）条线段上。

**算法简述**：

首先，初始化一个空的event queue，记作 ***Q***。然后把集合 ***S*** 里线段的end points都插入到 ***Q*** 中，当一个end point是线段的upper point时，要同时带上其所在的线段的信息（属于那条线段）。

然后，初始化一个空的status 数据结构，记作 ***J***。

之后，依次遍历 ***Q***，每次从 ***Q*** 中返回下一个event point *p*（同时 *p* 从 ***Q*** 中被移除），然后根据event point *p*，调用对 *p* 的处理函数***HandleEventPoint(p)***（如下）。这个遍历的终止条件是 ***Q*** 为空。（即这是一个while循环，而在遍历过程中可能有新event point加入 ***Q*** ）

**算法复杂度**：

O((n+k)logn)，其中，n是输入线段个数，k是输出个数

或者更具体地，O((n+I)logn)，其中，n是输入线段个数，I是交点个数



***HandleEventPoint(p)*** 步骤简述

- 输入是点 *p*

- 记 upper end point为 *p* 的线段集合为 ***U(p)***，这些线段是和点 *p* 对应存储的。如果线段是水平的，它的upper end point是左边的端点。

- 在status ***J*** 中找到所有包含点 *p* 的线段，它们都是相邻的，记 ***L(p)*** 是lower endpoint为 *p* 的线段集合，记 ***C(p)*** 是线段中间包含点 *p* 的线段集合（即点 *p* 是它们之间某两条或几条线段的交点）。

- 如果 ***L(p)*** ∪ ***U(p)*** ∪***C(p)*** 至少有一条线段，就说明点 *p* 是一个交点

  - 报告这个结构，并同时报告它所在的线段（在***L(p)***， ***U(p)*** 和 ***C(p)*** 中）

- 从status ***J*** 中删除***L(p)*** ∪***C(p)*** （即它们的并集）

- 向status ***J*** 中添加***U(p)*** ∪***C(p)*** （即它们的并集），并且插入的这些线段的顺序是，按照它们和sweep line在 *p* 稍下方一点位置相交的顺序。如果有线段是水平的，那么它要排在其他线段的最后面。

- 从上面的两个步骤可以得到，删除了***C(p)*** 又添加了***C(p)*** ，那么***C(p)*** 中的线段在status ***J*** 中的顺序逆序了。

- 如果***U(p)*** ∪***C(p)*** （即它们的并集）为空集

  - 把 status ***J*** 中，在 *p* 点左右两边的线段记为 *sl* 和 *sr*，调用寻找event point的函数***FindNewEvent(sl, sr, p)***

    如果 *sl* 或 *sr* 不存在，就忽略此步骤。

- 如果***U(p)*** ∪***C(p)*** （即它们的并集）不是空集

  - 把既在 ***U(p)*** ∪***C(p)*** 中又在status ***J*** 中，最左边的线段记作 *s1*，把在status ***J*** 中 *s1* 左边的线段记作 *sl*，然后调用寻找event point的函数***FindNewEvent(sl, s1, p)***。

    如果 *sl* 不存在，就忽略此步骤。

  - 把既在 ***U(p)*** ∪***C(p)*** 中又在status ***J*** 中，最右边的线段记作 *s2*，把在status ***J*** 中 *s1* 右边的线段记作 *sr*，然后调用寻找event point的函数***FindNewEvent(s2, sr, p)***

    如果 *sr* 不存在，就忽略此步骤。



***FindNewEvent(sl, sr, p)*** 步骤简述

- 如果线段 *sl* 和 *sr* 在sweep line的下方相交，或者就在sweep line上相交并且在当前event point *p* 的右边，那么这个新的交点就是在 ***Q*** 中还没出现的新的event point
  - 把这个新的交点加入到 ***Q*** 中



Lemma 2.2 和Lemma 2.3 分别是这个算法的正确性，以及算法的时间复杂度的证明。

根据这两个引理，得出Theorem 2.4。

>  Lemma 2.2 Algorithm FINDINTERSECTIONS computes all intersection points and the segments that contain it correctly.
>
> Lemma 2.3 The running time of Algorithm FINDINTERSECTIONS for a set S of n line segments in the plane is O(nlogn+I logn), where I is the number of intersection points of segments in S.
>
> Theorem 2.4 Let S be a set of n line segments in the plane. All intersection points in S, with for each intersection point the segments involved in it, can be reported in O(nlogn+I logn) time and O(n) space, where I is the number of intersection points.



### 2.2 The Doubly-Connected Edge List

引出了**可平面图**（planar graph, or planar embedding graph）的概念，引出可平面图的点（vertex）、线（edge）、面（face）。

同时引出了我们需要的应用，即确定哪个面（face）是包含所给定的一个点（given point）的。

引出了数据结构 ***doubly-connected edge list***，即 ***doubly-connected edge list*** 包含了一个平面细分（subdivision）上的face，edge，vertex的记录（record），并且除了几何和拓扑信息外，可能还有一些其他额外的信息，这个额外的信息叫做 ***information attribute*** （例如，一个face可能代表的是一种植被的覆盖，那么这个植被的种类就可以是这个额外的信息）。

这个 ***doubly-connected edge list*** 数据结构上的几何与拓扑信息，需要允许我们支持以下的一些操作

- 逆时针遍历这些face的edges，同时也能容易地反方向（顺时针）遍历。（这就要求edge直接有指向前一个和后一个的指针）

- 因为一个edge是两个face的边界，所以edge上需要有两个指针来指向这两个face

- 为了更方便表示当前描述的edge是哪个face的edge，可以把一条edge拆解为两条 ***half-edge***

  - 这两条half-edge是不同face的，而且每个half-edge都有唯一的指向前一个half-edge和执行后一个half-edge的指针
  - 而这同样意味着，一条half-edge只属于同一个face
  - 对于同一条edge的两条half-edge，我们把它们叫做 ***twins***
  - 我们把half-edge定义为有方向的，沿着half-edge走，face就在它的左边，所以这个方向是**逆时针**
  - 把half-edge定义为一个向量，origin（起点）是v，终点（destination）是w。所以它的twin half-edge的起点就是w，而终点是v。
  - 根据上面的定义，为了访问face的边界，可以只存储一个指向half-edge的指针，这样就可以沿着逆时针方向遍历这个face的所有half-edge了。

- 为了在表示洞（hole）时，仍然有沿着half-edge走时，face还在它的左边，就把洞的half-edge的方向定义为顺时针。

  而且，为了表示洞，需要需要有两个指向half-edge的指针，一个逆时针表示包含洞的face的边界，一个顺时针表示洞本身。

- 还可以存储多个half-edge的指针，而且这些指针沿着这些edge遍历起来的时候，没有重复的edge，这就是isolated island的形式（为了简化期间，书中暂时不作讨论）

**总结起来**，doubly-connected edge list数据结构有三种记录数据（record）

- vertex record

  它用来记录每个vertex（记作v）的坐标Coordinate(v)，并且它还有一个指针$IncidentEdge(v)$指向一条half-edge，而且这条half-edge的起点就是v

- face record

  一个face（记作$f$）

  - 存储一个指针$OuterComponent(f)$，指向的是outer boundary的half-edge。（如果face是unbound，即open edges的话，这个指针就是空？）
  - 还存储一个指针$InnerComponent(f)$，指向的是inner boundary的half-edge，这是用来表示洞的

- half-edge record

  一个half-edge（记作$e$）

  - 存储一个指针$Origin(e)$指向它的起点（origin）
  - 存储一个指针$Twin(e)$指向它的twin half-edge
  - 存储一个指针$IncidentFace(e)$，表示它绑定（bound）的face
  - 存储一个指向它前面half-edge的指针$Prev(e)$
  - 存储一个指向它后面half-edge的指针$Next(e)$

  没有必要存储它的终点（destination），因为可以通过$Origin(Twin(e))$得到。

本节还画了vertex，edge，half-edge，face以及上面提到的各种record的示意图，如下。

（图暂时省略，图位于第32页，页码是41）

这里也提到了，有时候有些record在一些应用中不是必须的（比如river和road构成的face，在某些应用中没有太多意义），所以在实现的时候可以适当忽略，以便在算法实现中更方便地调整其他数据。



### 2.3 Computing the Overlay of Two Subdivisions

简而言之，计算两个subdivision的overlay，就是根据两个subdivision的doubly-connected edge list（记作S1和S2），计算出一个新的doubly-connected edge list表示的subdivision（记作$O(S_1, S_2)$ ）。

（此处的图为，Figure 2.4，Overlaying two subdivisions）

这个overlay，可以看做是S1的edges被S2的edges所切割，而S1中的大部分edge其实可以在新生成的doubly-connected edge list中来复用，仅那些被S2的edges所真正切割到的S1的edges，才需要在新生成的$O(S_1, S_2)$ 被更新。

为了计算overlay结果，要把两个doubly-connected edge list（S1和S2），拷贝到一个新的doubly-connected edge list中去。拷贝的结果当然不是一个合法的doubly-connected edge list，因为它不能代表一个平面的细分（subdivision）。overlay算法的任务就是，把这个不合法的doubly-connected edge list，通过计算两个network edges之间的交点，并把两个doubly-connected edge list的部分区域连接起来，从而最终得到一个合法的doubly-connected edge list，即结果$O(S_1, S_2)$ 。

下面首先讨论的是，最终的overlay结果$O(S_1, S_2)$ 中的vertex和half-edge records，是如何被计算出来的。（关于新生成的face record，因为比较复杂，稍后再讨论）

计算$O(S_1, S_2)$ 的办法，利用了前面提到的计算line segments交点的plane sweep algorithm。算法操作的对象是，包含了S1和S2中所有line segment的线段集合（一个新的线段集合拷贝）。

在plane sweep algorithm中，需要两个数据结构，分别是event point的集合Q，以及status structure J。

Q是用来存储event point的（BST实现），而J是用来存储和sweep line相交的那些line segment的集合的（是有序的，在plane上是从左向右依次和sweep line相交的，也是BST实现的）。

除了这个两个数据结构之外，还需要维护一个doubly-connected edge list的数据结构$D$，它的初始值是从S1和S2拷贝而来，也就是说它的初始值是包含了S1和S2的所有line segment的集合。而随着sweep line的向下移动，$D$会随之而更新，最终变成一个合理的doubly-connected edge list。

如果一个$D$中的edge和sweep line相交而要被放入status J中时，我们需要用指针把放入J中的edge和它来自于$D$中的哪个half-edge record联系起来，这样当遇到一个intersection point时，我们就能够方便地找到$D$中的哪一个half-edge record（或哪一部分）需要被更新和调整。

在sweep line向下扫描的过程中，sweep line上面是已经计算好的最终overlay结果的一部分，是不再变化的。



当遇到一个event point时候的处理：当event point是来自原先同一个subdivision的edges时，那么这个event point是可以被复用的；但如果event point是来自原先两个subdivision的不同edges时，那么我们就需要更新数据结构$D$，更新（加入或删除）某些edges，以便把两个subdivision通过新的intersection point而连接起来。



这里通过举例，说明了一个subdivision中的一条edge，是如何和另一个subdivision中的其他几个edge相交，然后做处理的。这个过程比较tedious，但是不难（difficult）

（图为Figure 2.5，图位于第35页，页码是44）

这里主要结合图形，说明了在新生成了两条edge（对应的是两队half-edge pair）之后，如何调整它们以及周围的edge的Next()和Prev()指针。

值得说明的是，这个例子中，一条edge恰好经过的是另一个subdivision的一个vertex，因此，在调整新产生的edge的prev和next的时候，是按照clockwise的转向，找到第一个相邻的edge作为Next()指针所指向的edge，而按照anti-clockwise的转向，找到其第一个相邻的edge作为Prev()指针所指向的edge。这个可以结合图的说明清晰容易地看到。



除了更新生成的新half-edge pair，还要找到$O(S_1, S_2)$ 中每个face $f$ 的 $OuterComponent(f)$ （指向一个表示outer boundary的half-edge）和$InnerComponent(f)$ （指向一个或几个half-edge的指针，表示一个或多个洞）。还要给每个edge的$IncidentFace()$设定合理的指针指向face record。最后，每个$face$还要用原先两个subdivision中包含这个$face$的face name来给它做label。



如何判断一个half-edges组成的boundary是outer boundary，还是表示hole的inner boundary？

选定leftmost的vertex（in case of ties，choose lowest of leftmost），因为沿着half-edge的走向是clockwise的就是outer boundary，所以计算这个vertex前后两个相邻的（有序的）half-edge的夹角，如果是小于$90°$，那么就是outer vertex的half-edge，如果是大于$90°$，就是inner boundary的half-edge。这个特性仅适用于leftmost（或lowest of leftmost if ties）的vertex。

（这里的图位于第36页，页码是45）



通过一个图的例子，说明了如何确定一个face $f$是由一个或几个cycle组成的。如果是多个cycles组成，一般有几个洞的cycle（half-edges是顺时针的）和一个outer cycle（for outer boundary）组成，而且一个洞要通过对应的数据结构（比如class上的成员变量）连接到另一个洞或outer boundary上，这样才能表明这些cycles组成的是同一个face $f$。



> Lemma 2.5 Each connected component of the graph $G$ corresponds exactly to the set of cycles incident to one face.

关于这个lemma的证明，没看懂。

总之，他想说明的是，一个face上的洞，是和这同一个face上的其他洞相连的，或者是和这个face对应的$OuterComponent(f)$ 相连接，而这些相连接的洞（实际上就是$InnerComponent(f)$ ？）和$OuterComponent(f)$ 就组成了这个face $f$。



如果构建graph $G$？

构建graph $G$，实际上是把这些$InnerComponent(f)$（即洞）和$OuterComponent(f)$ 直接合理地用书中所谓的“arc”连接起来。

对于每个表示洞的cycle的leftmost的vertex $v$，如果有一条half-edge $e$，是这个vertex $v$ 左边第一个邻近的half-edge，那么就在这两个node直接就用一条arc连接起来。

为了快速（有效）地找到这些node，每个half-edge的record上有指针指向这些node，表示这些node在这个graph $G$ 的哪个cycle上。

而找到一条vertex左边的、相邻的第一个half-edge，是在plane sweep algorithm中sweep line向下扫描时得出的，而且这个相邻的左边第一个half-edge，是位于另外一个cycle上的。

（这里用来说明的图，位于第37页，页码是46）



最后一件事情是，在overlay结果 $O(S_1, S_2)$ 中，每个face $f$ 都要找到它原先分别在 $S_1$ 和 $S_2$ 中的label。

假如一个vertex $v$ 是来自 $S_1$ 的一条edge $e_1$ 和 $S_2$ 的一条edge $e_2$ 的相交得到新的点，那么可以从edge $e_1$ 和 $e_2$ 的 $IncidentFace(f)$ 得到各自在原先 $S_1$ 和 $S_2$ 中的label name。

但如果vertex $v$ 本身就是来自 $S_1$ 的一个点（或者$S_2$ 的一个点），那么我们首先能得知它来自 $S_1$ 的哪个face（因为能从 $v$ 对应的half-edge的 $IncidentFace(f)$ 上得到。其次，就需要找到在 $S_2$ 上的哪个face包含这个vertex $v$。

书中在此处没有展开解释，只说明了仍然使用本章介绍共的plane sweep algorithm就可以找到，而且也不用再次调用这个plane sweep algorithm，而是在原先扫描的过程中，就可以找到。



***MapOverlay***算法简述

**输入**：二维平面上的两个平面细分（subdivision）$S_1$ 和 $S_2$，它们都是以doubly-connected edge list表示。

**输出**：$S_1$ 和 $S_2$ 的overlay $D$，并且也是以doubly-connected edge list表示。

**算法简述**：

1. 新建一个doubly-connected edge list $D$，并把两个原始输入$S_1$ 和 $S_2$ 拷贝到 $D$ 中

2. 通过第2.1节中提到的plane sweep algorithm，计算$S_1$ 和 $S_2$ 中每个edge的交点，除了在每个event point时更新 $J$ （status）和 $Q$ （event point），还需要处理
   - 更新步骤1中建立的的doubly-connected edge list $D$（前面的叙述中有举例如果$S_1$的一条edge穿过了$S_2$的一个vertex时，如何生成新的half-edge pair，以及复用原先的half-edge pair并调整相应的record指针）
   - 在处理$D$中的每个event point之后，记录每个event point左边第一个half-edge的信息

3. 经过步骤2，$D$已经是$S_1$ 和 $S_2$ 的overlay结果$O(S_1, S_2)$，但是每个face $f$ 的信息还没有计算出来

4. 遍历$D$，确定$O(S_1, S_2)$中的boundary cycles

5. 构建graph $G$。这样的 $G$ 是一个或多个component组成。每个component由一个或几个表示boundary的cycle(s)组成，如果一个boundary cycle表示的是洞，那么它的leftmost的vertex就要通过一个所谓的"arc"连接到另外一个表示洞的boundary cycle（或者最终连接到一个表示非洞的boundary cycle上）

6. 对于步骤5中建立的graph $G$ 的每个component：

   假设 $C$ 是这个component中唯一的outer boundary cycle，并用 $f$ 表示由这个cycle所包含的face。

   创建 $f$ 的face record，设定指针 $OuterComponent(f)$ 指向 $C$ 中的某一个half-edge即可；设定指针数组（或列表）$InnerComponent(f)$ ，它是这个component中每个洞上的某一个half-edge的指针集合；把这个component中每条half-edge所指向face的指针$IncidentFace(e)$ 设置为指向 $f$ 的face record。

7. 结果$O(S_1, S_2)$中的每个face，都用$S_1$ 和 $S_2$ 中对应的face名字做标记（label）

**算法时间复杂度**：$O(nlogn + klogn)$



> Theorem 2.6 Let $S_1$ be a planar subdivision of complexity $n_1$, let $S_2$ be a subdivision of complexity $n_2$, and let $n := n_1 +n_2$. The overlay of $S_1$ and $S_2$ can be constructed in $O(nlogn + klogn)$ time, where k is the complexity of the overlay.

算法复杂度的计算

- 步骤1中，拷贝两个doubly-connected edge list 到 $D$ 中，算法复杂度是 $O(n)$
- 步骤2中，plane sweep algorithm的时间复杂度是 $O(nlogn + klogn)$
- 步骤4-6中，用来填写face record的时间复杂度是和 $O(S_1, S_2)$ 线性相关的
- 步骤7中，把结果中的每个face用$S_1$ 和 $S_2$ 中对应的face名字做标记的时间复杂度是 $O(nlogn + klogn)$



### 2.4 Boolean Operations

Map overlay算法最为常见的应用之一，就是polygon的Boolean操作，即 **与**（$AND$， ∩），**或**（$OR$，∪），**非**（$NOT$，\）。

（这里用来说明的图，位于第39页，页码是30）

按照前面所述，把两个polygon看做是两个平面细分（subdivision），记作 $P_1$ 和 $P_2$，那么map overlay的结果$O(P_1, P_2)$ 是一个新的平面细分，并且也用一个doubly-connected edge list所表示。这里最重要的是，作为结果的平面细分的每个face record $f$，都是用原来两个平面细分 $P_1$ 和 $P_2$ 共同标识的。

所以，Boolean操作的求解转换为：

- 如果计算的是$P_1$ 和 $P_2$的交集（ $P_1 ∩ P_2$），我们就从overlay结果中找到那些同时带有$P_1$ 和 $P_2$ label的face。
- 如果计算的是$P_1$ 和 $P_2$的并集（ $P_1 ∪ P_2$），我们就从overlay结果中找到那些带有$P_1$ 或 $P_2$ 或同时带有$P_1$ 和 $P_2$label 的face。
- 如果计算的是$P_1$ 和 $P_2$的差集（ $P_1 \ P_2$），我们就从overlay结果中找到那些只带有$P_1$ 、不带有 $P_2$ label的face。



### 2.5 Notes and Comments

line segment intersection problem是计算几何中最为基础的问题之一。

本章提到的 $O(nlogn + klogn)$ 时间复杂度的算法是1979年 **Bentley** 和 **Ottmann** 给出的。

求得所有线段交点的时间复杂度的下限是 $\Omega(nlogn + k)$ ，当 $k$ 值较大时，这样的算法不是最优的。多位研究者研究后，Clarkson&Shor这两人，和Mulmuley分别给出了randomized incremental algorithms，时间复杂度是$O(nlogn + k)$，而空间复杂度分别是$O(n)$和$O(k)$，而且这两种种randomized algorithms也可以用来计算curve。Balaban后来给出了第一种 deterministic algorithm，时间和空间复杂度分别是$O(nlogn + k)$和$O(n)$。

有一种叫做**red-blue line segment intersection problem**的问题，是line segment intersection problem的特殊情况。它是指两个line segment的集合（red segments和blue segments），每个segment集合内部两两segment之间没有交点，那么求解这两个集合之间的segment intersection，**Mairson** 和 **Stolfi**给出的算法时间和空间复杂度分别是$O(nlogn + k)$和$O(n)$。

实际上，**red-blue line segment intersection problem**的问题就是network overlay problem。

line segment intersection counting problem是计算线段交点个数的问题（而不是报告所有交点坐标），所以它的输出就是一个整型数，不依赖于交点个数算法的时间复杂度是$O(n^\frac{4}{3}log^cn)$，其中 $c$ 是某个小值常数。

Plane sweep是设计几何算法中最为重要的范式之一。第3章plane sweep用它来处理polygon triangulation
problem，第7章用它来计算Voronoi diagram（维诺图） of a set of points。本章提到的sweep line是一条水平的（虚拟）直线，在某些情况下，sweep line可能是其他的形式，比如第15章提到的可能是rotating line。plane sweep也可以用于更高维度的空间，这时叫做space sweep algorithms。

本章提到的用来存储平面细分（subdivision）的数据结构是the doubly-connected edge list，Muller 和 Preparata描述了这种数据结构。此外，还有Baumgart的the winged edge structure，Guibas 和Stolfi的the quad edge structure等。这些数据结构的差异总体上不大。



### 2.6 References

- [库拉托夫斯基定理](https://baike.baidu.com/item/%E5%BA%93%E6%8B%89%E6%89%98%E5%A4%AB%E6%96%AF%E5%9F%BA%E5%AE%9A%E7%90%86/2748841?fr=aladdin)
- [可平面图（planar graph）](https://baike.baidu.com/item/%E5%8F%AF%E5%B9%B3%E9%9D%A2%E5%9B%BE/19138688?fr=aladdin)
- [Geometry Symbol Names](https://www.rapidtables.com/math/symbols/Geometry_Symbols.html)



## 3 Polygon Triangulation - Guarding an Art Gallery

作者通过前言，引出了所谓的 ***Art Gallery Problem***，即我们需要多少台摄像机才能监控画廊？并且我们需要在什么位置摆放它们？

> How many cameras do we need to guard a given gallery and how do we decide where to place them?



### 3.1 Guarding and Triangulations

为了准确描述问题，把实际当中的画廊化简为二维平面上的多边形，而且是由线段连接成的没有自相交的多边形，因此就不包括洞，这样的多边形叫做simple polygon。摄像机是这个polygon当中的一个点，如果一个点到摄像机的连线位于这个polygon内部，那么这个点就是可以被这个摄像机看到的点。

我们以一个多边形polygon的点的个数 $n$ 作为摄像机的数量的上限。对于convex hull（凸多边形），实际上只需要一个摄像机就可以。我们需要给出的是对于有着 $n$ 个点的任意polygon的摄像机个数的上限（bound），而不是对于任意polygon的最少摄像机的个数，因为这个是 $NP$ 难题。

假设 $\mathcal{P}$ 是一个有 $n$ 个顶点（vertices）的多边形，为了确定摄像机的个数，我们可以把这个多边形分解成多个容易监控的**三角形**。这种三角形划分是通过连接每一对顶点得到的**对角线**得到的。

这样的对角线连接的是多边形的两个顶起，并且这条对角线必须位于多边形内部。以最多数量的、不相交的对角线把一个多边形进行三角形划分的办法，叫做 ***triangulation of the polygon***（多边形的三角形划分）。

要求这样的对角线的数量最大的原因是避免有原先多边形上的顶点落在划分之后的三角形的边上。而这在有三个共线顶点的多边形中是可能发生的。

三角形划分通常不是唯一的。但三角形是否总是存在？三角形划分之后有多少个三角形？

**定理3.1，每一个简单多边形存在一个三角形划分，并且一个有 $n$ 个顶点的简单多边形可以划分为 $n-2$ 个三角形。**

> Theorem 3.1 Every simple polygon admits a triangulation, and any triangulation of a simple polygon with n vertices consists of exactly n−2 triangles.

这个定理的简单证明见第55页（页码47）。其中没看懂的是证明diagonal open segment存在的时候，为什么 $v$ 和 $v'$ 构成的open segment $\overrightarrow{vv'}$ 不会和 $\mathcal{P}$ 的其他edge相交？？？（需要以后再查看）。

应该想明白了：如果这样的segment $\overrightarrow{vv'}$ 和 $\mathcal{P}$ 的一条edge相交的话，那么点 $v'$ 肯定位于这条edge的另外一侧，这也就是说，那条edge上的两个点，肯定有一个比 $v'$ 离 $v$ 更近，这样就有产生矛盾，所以反证法得证$v'$ 就是离$\overrightarrow{uw}$ 最远的（并且在triangle里面的）点。

这个定理同时也说明了**如何找到一条对角线的方法**：

找到这个simple polygon最左下的顶点 $v$，首先尝试连接它的两个直接相邻的点 $u$ 和 $w$

- 如果 $\overrightarrow{uw}$ 位于这个多边形的内部，那么$\overrightarrow{uw}$ 就是这个多边形的一条对角线。
- 如果 $\overrightarrow{uw}$ 位于这个多边形的外部或横跨这个多边形的内外，那么就一定有一些顶点是位于由点 $v$， $u$ 和 $w$ 组成的三角形 $\bigtriangleup{vuw}$ 内部，找到这些点里面距离 $\overrightarrow{uw}$ 最远的点记作 $v'$，那么 $vv'$ 就一定是这个多边形的一条对角线。（至于原因，见上面的分析）



有了上述的定理，那么用来监控画廊的摄像机个数就可以是 $n-2$，但这有点太多了。因为，比如把一台摄像机放在对角线上，那么它就可以监控两个三角形（区域）；如果放在某些顶点上，那么摄像机似乎可以监控更多的区域。

假设 $\mathcal{T}_p$ 是多边形 $\mathcal{P}$ 的一个三角形划分（triangulation），给多边形的每个顶点（vertex）三种颜色中的其中一种：黑（black），白（white）和灰（gray），**并且使得**，每两个由多边形的edge（或对角线）相连的两个vertex，其颜色不同。这叫作 ***3-coloring of a triangulated polygon***（三角形划分的一种三色赋值）。

在这样的3-coloring of a triangulated polygon中，每个三角形都会有黑（black），白（white）和灰（gray）三种颜色的顶点。比如我们把摄像机放在那些灰色的顶点上，就可以实现监控整个画廊的目的。而通过选择放置在三种颜色的某种颜色上，我们就能实现使用至多 $\lfloor n/3 \rfloor$ 台摄像机来监控整个画廊。

但这样的3-coloring of a triangulated polygon总是存在吗？答案是肯定的。

要证明这一点，首先要查看所谓的**对偶图**（dual graph）。在这个对偶图 $\mathcal{G}(\mathcal{T}_\mathcal{P})$ 中，（已经三角形划分的多边形的）每个三角形都有一个点（node，比如中心），把这个点对应的三角形记作 $t(\nu)$。每两个node $\nu$ 和 $\mu$ 之间有连线（arc），这样的连线（arcs）对应的是 $\mathcal{T}_p$  的对角线。每条对角线把多边形 $\mathcal{P}$ 一分为二，类似地，删去对偶图 $\mathcal{G}(\mathcal{T}_\mathcal{P})$ 的任意一条edge，这个对偶图 $\mathcal{G}(\mathcal{T}_\mathcal{P})$ 也会被一分为二。所以对偶图 $\mathcal{G}(\mathcal{T}_\mathcal{P})$ 是一棵树（tree），但对带洞的多边形不成立。这就是说我们可以用简单图的遍历找到3-coloring（比如深度遍历）。

（这里用来说明的图，位于第56页，页码是48）

找到一种3-coloring的办法描述：因为实际上对偶图 $\mathcal{G}(\mathcal{T}_\mathcal{P})$ 是一棵树，我们进行深度遍历时做相同的事情，即，遍历的过程中依次遇到每个三角形，并将其顶点涂为黑（black），白（white）和灰（gray）三种颜色，并且确保相邻的两个顶点颜色不同。而这也意味着，已经遍历过的所有三角形的顶点都已经涂上了合理的三种颜色。我们从对偶图 $\mathcal{G}(\mathcal{T}_\mathcal{P})$ 的任意一个node出发开始深度遍历，假设当前遍历到了node $\nu$，它的前一个node是 $\mu$，因此 $t(\nu)$ 和 $t(\mu)$ 有一条共同的对角线，根据前面的假设，所有已经遍历过的三角形的顶点已经涂色，那么  $t(\mu)$ 的三个顶点已经有了颜色，这也就是说 $t(\nu)$ 的三个顶点中已经有两个有了颜色，那么 $t(\nu)$ 剩下的那个顶点的颜色也就确定了，而且这也是因为对偶图 $\mathcal{G}(\mathcal{T}_\mathcal{P})$ 是一棵树，邻近node $\nu$ 的节点都还没有被访问到，所以 $t(\nu)$ 剩下的那个顶点颜色就可以涂成剩余的那种颜色。

总结一下就是，简单多边形的三角形划分，总是可以3-coloring，而且简单多边形（表示画廊）可以用至多 $\lfloor n/3 \rfloor$ 台摄像机来监控。

也许对某些多边形用不了 $\lfloor n/3 \rfloor$ 台摄像机，但对任意的有 $n$ 个顶点的多边形，最差的情况下乐观结果就需要 $\lfloor n/3 \rfloor$ 台摄像机。这里文中以一个有很多尖刺、基于一个水平base edge的组合多边形（comb-shaped）进行了说明，在这种polygon里面，找不到一个位置放置摄像机去同时看到两个尖刺区域。

（这里用来说明的图，位于第56页，页码是48，从上往下第2个图）



**定理3.2，（画廊定理），对任意有 $n$ 个顶点的简单多边形， $\lfloor n/3 \rfloor$ 台摄像机只是偶尔是必须的（因为大多数情况下只要更少），而且总是可以满足从多边形内部的任意一点看到至少一台摄像机的要求。**

> Theorem 3.2 (Art Gallery Theorem) For a simple polygon with n vertices, $\lfloor n/3 \rfloor$ cameras are occasionally necessary and always sufficient to have every point in the polygon visible from at least one of the cameras.



**定理3.3，对任意有 $n$ 个顶点的简单多边形，从多边形内部的任意一点看到至少一台摄像机，计算这样的至多 $\lfloor n/3 \rfloor$ 台摄像机的时间复杂度是 $O(nlogn)$。**

> Theorem 3.3 Let $\mathcal{P}$  be a simple polygon with n vertices. A set of $\lfloor n/3 \rfloor$ camera positions in $\mathcal{P}$ such that any point inside $\mathcal{P}$ is visible from at least one of the cameras can be computed in $O(nlogn)$ time.



### 3.2 Partitioning a Polygon into Monotone Pieces

前面提到的定理3.1，不仅说明了存在simple polygon的三角形划分，而且同时也阐述了一种寻找简单多边形对角线的办法。这种办法找每条对角线的时间复杂度是线性的，那么采用这种办法找到simple polygon的一种三角形划分的时间复杂度最差就是二次方的（quadratic）。

但对于convex polygon，可以从其任意一点出发，连接它与其他顶点的连线（除了它直接相邻的两个顶点），得到的结果就是一种三角形划分，而且时间是线性的。

所以，比较好的办法是，把一个多边形先分解为convex polygons，然后再做三角形划分。但实际上把多边形分解成凸多边形，这和三角形划分一样困难。

退而求其次，就先把多边形分解成所谓的monotone pieces（**单调多边形**），这就容易很多。



什么是简单的**单调多边形**（monotone simple polygon）？

如果一个多边形是关于某一条直线 $\ell$ 是**单调**的，那么对于任意一条垂直于 $\ell$ 的直线 $\ell'$，它和这个多边形的相交部分是连接的。换句话说，这个相交的部分就是一条线段，或者一个点，或者没有相交。（就是说不会有多个相交的线段或点）

> A simple polygon is called monotone with respect to a line $\ell$ if for any line $\ell'$ perpendicular to $\ell$ the intersection of the polygon with $\ell'$ is connected. In other words, the intersection should be a line segment, a point, or empty.

如果一个多边形是关于*y*轴单调，那么从最上面的顶点开始，沿着多边形的轮廓线段（向左或向右），到达最下面的顶点，我们总是向下移动或者水平移动，而从不会向上移动。这是关于*y*轴单调的多边形的一个特性。

（这里用来说明的图，位于第57页，页码是49，从上往下第1个图）



所以，把一个多边形 $\mathcal{P}$ 做三角划分，首先是把它分解成沿 *y* 轴单调的多边形，然后再对这些单调多边形做三角划分。

为了说明多边形的顶点的类型，定义一个点在另一个点上方和下方的概念。

- 点 $p$ 在点 $q$ 下方（below）

  $p_y < q_y$，或者当$p_y = q_y$时，$p_x < q_x$

- 点 $p$ 在点 $q$ 上方（above）

  $p_y > q_y$，或者当$p_y = q_y$时，$p_x > q_x$



什么是多边形的**turn vertex**（**转向顶点**）？

从最高的顶点（topmost），沿着多边形的轮廓边，向左或向右出发，走向最低的顶点（bottommost），当到达一个顶点（vertex）时，边的走向从向下变为向上，或者从向上变为向下，这个点就是**turn vertex**（**转向顶点**）。

而把多边形划分成单调多边形，就是为了消除这些**turn vertex**（**转向顶点**），而通过添加对角线，就可以做到。

假如一个vertex $v$ 相接的两条edge都是向下的，那么我们需要从 $v$ 出发找一条向上的对角线（记作$vv'$），这样把当前的多边形一分为二。$v$ 在两个划分出来的多边形里面，和它相接的原来的edge是向下的，而从它出发的对角线是向上的，所以 $v$ 就不再是一个**turn vertex**（**转向顶点**）了。

同理，如果$v$ 相接的两条edge都是向上的，我们需要找的就是一条向下的对角线，以便划分多边形，消除这个**turn vertex**（**转向顶点**）。 

（这里用来说明的图，位于第57页，页码是49，从上往下第2个图）



定义一个多边形中5种类型的vertex

==（这里用来说明的图，位于第58页，页码是50）==

- **start vertex**

  如果顶点 $v$ 是start vertex，那么它相邻的两个vertex都在它的**下方**（below，定义见前述），并且顶点 $v$ 所在的多边形的内角比 $\pi$ **小**。

- **end vertex**

  如果顶点 $v$ 是end vertex，那么它相邻的两个vertex都在它的**上方**（above），并且顶点 $v$ 所在的多边形的内角比 $\pi$ **小**。

- **regular vertex**

  不是turn vertex的vertex都是regular vertex。所以，regular vertex相邻的两个vertex，一个在它**上方**，一个在它**下方**。

- **split vertex**

  如果顶点 $v$ 是split vertex，那么它相邻的两个vertex都在它的**下方**（below），并且顶点 $v$ 所在的多边形的内角比 $\pi$ **大**。（和start vertex类似）

- **merge vertex**

  如果顶点 $v$ 是merge vertex，那么它相邻的两个vertex都在它的**上方**（above），并且顶点 $v$ 所在的多边形的内角比 $\pi$ **大**。（和end vertex类似）





引理3.4 如果一个多边形没有split vertex，也没有merge vertex，那么它就是一个关于y轴单调的多边形。

> Lemma 3.4 A polygon is y-monotone if it has no split vertices or merge vertices.

==（这里用来说明的图，位于第59页，页码是51）==

证明：办法是证明这个引理的充要条件，即，如果一个多边形不是y轴单调的，那么它就一定有一个split vertex或者merge vertex。

根据非单调多边形的定义，如果一个多边形不是y轴单调的（y-monotone），那么就一定有一条水平直线 $\ell$ 和这个多边形相交，而且存在大于1个相交的部分（相交点或相交线段）。

假设我们选取这样的一条水平直线 $\ell$ 使得最左边和多边形相交的是一条线段，记这条线段左点是 $p$，右点是 $q$。从 $q$ 出发，沿着多边形的边走，使得多边形位于行走方向的左侧（这意味着我们是从 $q$ 开始向上行走）。直到多边形和水平直线 $\ell$ 相交的一点 $r$。

- 如果点 $r \neq p$，那么点 $q$ 和 $r$ 之间的多边形轮廓上的最**高**的一点就是split vertex。

- 如果点 $r = p$，那么我们从点 $q$ 再次出发，但这次是沿着和之前相反的方向行走，同样地，会碰到多边形和水平直线 $\ell$ 相交的点 $r'$。

  这个点 $r'$ 必定和 $p$ 不同（$r' \neq p$），原因是如果$r' \neq p$，这就意味着水平直线 $\ell$ 和多边形只有一条相交的线段，即 $pq$（或 $qr'$），而这和多边形是关于y轴**非单调**矛盾。

  所以点 $r'$ 和 $p$ 不同，而这就意味着点 $r'$ 和 $p$ 之间多边形轮廓上的最**低**的一点就是merge vertex。



引理3.4说明，如果我们消除了split vertex和merge vertex，那么多边形就能被分解成关于y轴单调的多边形了。而这，可以通过从split vertex引出一条向上的对角线、从merge vertex引出一条向下的对角线而实现。



如何给split vertices添加对角线？还是使用plane sweep method。

将多边形  $\mathcal{P}$ 的顶点按照逆时针记作 $v_1, v_2, ..., v_n$，同时把将多边形  $\mathcal{P}$ 的边（edge）按照逆时针记作 $e_1, e_2, ..., e_n$，并且当 $i$ 满足 $1 \le i \lt n$ 时，$e_i = \overline{v_iv_{i+1}}$，当 $i = n$ 时，$e_n = \overline{v_nv_1}$。

在plane sweep algorithm应用到当前场景中时，event point就是多边形的这些顶点，并且不会有新的event point加入。这些event point被存储在一个优先级队列 $\mathcal{Q} $ 中（priority queue），优先级就是y坐标值（如果两点有相同的y坐标，x坐标较小的优先级更高）。利用这样的优先级队列，下一个event point被找到的时间复杂度就是 $O(logn)$。

当sweep line到达一个split vertex $v_i$ 时，需要添加一条从 $v_i$ 出发向上的对角线。记多边形的两条边 $e_j$ 和 $e_k$ 分别是 $v_i$ 在sweep line（水平）上左右相邻的第一条edge（即 $e_j$， $e_k$ 和sweep line相交），然后找到 $e_j$ 和 $e_k$ 之间的高于 $v_i$ 的**最低**点（记作$helper(e_j)$），然后和 $v_i$ 连接即得到所求对角线。如果没有这样的点，就连接 $v_i$ 和 $e_j$ 或 $e_k$ 两条线段中某一条的上方的点（也记作（$helper(e_j)$）。

==（这里用来说明的图，位于第60页，页码是52的第1个图）==

当sweep line到达一个merge vertex $v_i$ 时，需要添加一条从 $v_i$ 出发向上的对角线。同样地，记多边形的两条边 $e_j$ 和 $e_k$ 分别是 $v_i$ 在sweep line（水平）上左右相邻的第一条edge（即 $e_j$， $e_k$ 和sweep line相交）。然后找到 $e_j$ 和 $e_k$ 之间的低于于 $v_i$ 的**最高**点，然后和 $v_i$ 连接即得到所求对角线。但此时 $v_i$ 就在sweep line上，而它之下的点还没有扫描到，所以我们此时找不到这样的点，但这样的点却可以在之后找到。当sweep line继续向下扫描遇到点 $v_m$ 时，如果它左边的第一条和sweep line相交的线就是 $e_j$，并且找到它的$helper(e_j)$ 就是 $v_i$，那么 $v_m$ 就是我们前面要找的这样的点。

所以，当我们替换一条edge $e_x$ 的$helper(e_x)$ 时，检查旧的helper点是不是一个merge vertex。如果是，就连接新的helper点和旧的helper点构成一条对角线。而当新的helper点是split vertex的时候，这样的对角线总是会被连接出来的，而此时如果旧的helper点还是一个merge vertex，那么这一条对角线就同时消除了split vertex和merge vertex。



在前面讨论添加对角线的算法中，对于每个vertex，我们需要找到它左边的edge。因此，我们把和sweep line相交的edge当做一棵二叉搜索树 $\mathcal{T}$ 的叶节点来存储，而且这些从左到右的叶节点依次对应从左到右和sweep line相间的的edge。

因为我们只关心在split vertex或merge vertex左边的edge，所以在这棵二叉搜索树 $\mathcal{T}$ 中只存储一种类型的edge，即，相对于这些edge，多边形 $\mathcal{P}$ 的内部都在这些edge的右边。同时每个edge我们都会存储它对应的helper（即$helper(e_j)$），这棵二叉搜索树 $\mathcal{T}$ 和它存储的这样的edge就构成了sweep line algorithm的status。当sweep line和一条edge开始相交，或者分开时，这个status就会被更新，一条edge的helper（即$helper(e_j)$）就可能会被替换。



假设多边形 $\mathcal{P}$ 是以doubly-connected edge list表示（如果是以逆时针的vertex list表示，就先转换为一个doubly-connected edge list），同样的，把多边形 $\mathcal{P}$ 划分之后的结果（单调多边形）和所添加的对角线，也用一个doubly-connected edge list $\mathcal{D}$ 来表示。在split vertex和merge vertex处计算出来的对角线，也加入到了这个doubly-connected edge list中。为了方便，存储在status中的每个edge，和它们在doubly-connected edge list 中对应的edge，互相有一个指针相互指向，这样的**交叉指针**就能使得这样的edge可以快速找到在另一个数据结构里面的对应edge。



***MakeMonotone***算法简述

**输入**：二维平面的一个简单多边形 $\mathcal{P}$， 它是以doubly-connected edge list $\mathcal{D}$ 表示。

**输出**：简单多边形 $\mathcal{P}$ 分解成的单调多边形 ，并且是存储在同一个doubly-connected edge list $\mathcal{D}$ 中。

**算法简述**：

1. 构建多边形 $\mathcal{P}$ 的顶点的一个优先级队列 $\mathcal{Q}$，排序是按照每个顶点的y坐标。如果两个顶点的y坐标相同，有较小的x坐标的点有更高的优先级。
1. 初始化一棵空的二叉搜索树 $\mathcal{T}$ 。
1. 执行循环：只要优先级队列 $\mathcal{Q}$ 不空，每次从其队列中取出优先级最高的一个顶点 $v_i$，然后根据这个顶点的类型（split/merge/...），调用对应的处理程序。



下面就是根据每个顶点的类型，对应的相应处理。当处理每个顶点vertex的时候，有两件必须做的事情

- 检查是否应该给一个vertex添加对角线。当一个vertex是split vertex，或者，在替换一个edge的helper（$helper(e_j)$），并发现前一个（旧的）helper是一个merge vertex的时候，就需要添加对角线。
- 更新status数据结构  $\mathcal{T}$ （即二叉搜索树）中的信息（通过前面提到的交叉指针）



==（下面几个针对不同类型vertex的处理，对应的一个例子的图在62页，页码是54）==

需要注意的是，本书中每个多边形vertex（下面的 $i$）的起始索引是`1`，而不是`0`。



算法 $HandleStartVertex(v_i)$ （**vertex是start vertex**）

1. 在二叉搜索树 $\mathcal{T}$ 中添加edge $e_i$，并且把$helper(e_i)$设定为 $v_i$。



算法 $HandleEndVertex(v_i)$ （**vertex是end vertex**）

1. 如果$helper(e_{i-1})$ 是merge vertex，就生成一条连接 $v_i$ 到 $helper(e_{i-1})$ 的对角线，并加入到doubly-connected edge list $\mathcal{D}$ 中。
2. 从二叉搜索树 $\mathcal{T}$ 中删除vertex $e_{i-1}$。



算法 $HandleSplitVertex(v_i)$ （**vertex是split vertex**）

1. 在二叉搜索树 $\mathcal{T}$ 中找到这个顶点 $v_i$ 左边的第一个（直接）邻居edge $e_j$ 。
2. 在doubly-connected edge list $\mathcal{D}$ 中，添加一条对角线，这条对角线用来连接 $v_i$ 和 $helper(e_j)$ 。
3.  $helper(e_j)$ $\longleftarrow$  $v_i$ （连接 $v_i$ 和 $helper(e_j)$ 的意思）
4. 在二叉搜索树 $\mathcal{T}$ 中插入edge $e_i$，并且把 $helper(e_i)$ 设定为vertex $v_i$。



算法 $HandleMergeVertex(v_i)$ （**vertex是Merge vertex**）

1. 如果$helper(e_{i-1})$ 是一个merge vertex，就生成一条连接 $v_i$ 到 $helper(e_{i-1})$​ 的对角线，并加入到doubly-connected edge list $\mathcal{D}$ 中。
2. 从二叉搜索树 $\mathcal{T}$ 中删除 vertex $e_{i-1}$。
3. 在二叉搜索树 $\mathcal{T}$ 中找到这个顶点 $v_i$ 左边的第一个（直接）邻居edge $e_j$ 。
4. 如果$helper(e_j)$ 是一个merge vertex，就生成一条连接 $v_i$ 到 $helper(e_j)$ 的对角线，并加入到doubly-connected edge list $\mathcal{D}$ 中。
5. $helper(e_j)$ $\longleftarrow$  $v_i$ （连接 $v_i$ 和 $helper(e_j)$ 的意思）



算法 $HandleRegularVertex(v_i)$ （**vertex是regular vertex**）

1. 处理这个regular vertex的前提是，多边形 $\mathcal{P}$ 的内部位于vertex $v_i$ 的右边。如果前提不成立，不用继续下面的处理。
2. 如果$helper(e_{i-1})$ 是一个merge vertex，就生成一条连接 $v_i$ 到 $helper(e_{i-1})$ 的对角线，并加入到doubly-connected edge list $\mathcal{D}$ 中，然后从二叉搜索树 $\mathcal{T}$ 中删除 vertex $e_{i-1}$，再在二叉搜索树 $\mathcal{T}$ 中添加edge $e_i$，并且把$helper(e_i)$设定为 $v_i$。
3. 如果$helper(e_{i-1})$ **不是**一个merge vertex，那就在二叉搜索树 $\mathcal{T}$ 中找到这个顶点 $v_i$ 左边的第一个（直接）邻居edge $e_j$ 。如果$helper(e_j)$ 是一个merge vertex，就生成一条连接 $v_i$ 到 $helper(e_j)$ 的对角线，并加入到doubly-connected edge list $\mathcal{D}$ 中（$helper(e_j)$ $\longleftarrow$  $v_i$ ）。















### 3.6 References

[Latex公式编辑器](https://latexlive.com/##)

[Latex数学字体](https://zhuanlan.zhihu.com/p/556258509)

































