# Reading Minutes for Effective Modern C++

This is for taking the notes when reading ***Effective Modern C++*** by ***Scott Meyers***.



# Errata Page

This is the ***[Errata Page](http://www.aristeia.com/BookErrata/emc++-errata.html)***



# Words

coax */kəʊks/* *v.*哄，劝诱；连哄带劝地得到；小心地摆弄（机器或装置）

turf

indebted

exasperation

pervasive

heuristic

variadic 

steer clear of 避开; 躲避; 绕开;

tyranny 暴虐，专横

reason about 推出

all but impossible 几乎不可能

enigmatic 神秘的；高深莫测的；谜一般的

hard-pressed 被紧紧追赶的；任务紧急而繁忙的；处境艰难的

hazy 雾蒙蒙的，朦胧的；记不清的，模糊的；

a pinch of 一撮，少许

adornment 装饰；装饰品（书中提到的是指一个类型的const or reference qualifiers）

niche *n.*合适（称心）的工作（活动）; *adj.* （产品）针对特定小群体的

foliage *n.*（植物的）枝叶，叶子

curve ball 使其很难被击打的弧线球

mondo *adj.*绝对的；完全的；（非正式）非凡的，卓绝的；相当

stir up 激起；煽动；搅拌；唤起

turbidity *n.*[分化] 浊度；浑浊；混浊度；混乱

purview *n.*范围，权限；视界；条款

as a matter of course 理所当然的（事）；自然地

revelation *n.*被揭示的真相，被揭露的内情；揭露，披露；出乎意料的事物，令人惊喜的发现；（上帝的）启示，默示；《启示录》（《圣经·新约》末卷，讲述上帝对圣约翰有关未来的启示）

parrot *v.*机械地模仿，鹦鹉学舌般重复

compilable 可编译的

elicit *v.*引出，得到；

palatable *adj.*美味的，可口的；愉快的

bedevil *vt.*使痛苦；虐待；使苦恼

dutifully *adv.*忠实地；忠贞地；尽责地，忠诚地

ins and outs 复杂细节；进进出出；盛衰

potholes  *n.*凹坑；坑槽；洞坑（pothole 的复数形式）

notwithstanding *prep.*虽然，尽管；*adv.*尽管如此；*conj.*虽然，尽管

amiss *adj.*有毛病的，有缺陷的；出差错的；*adv.*错误地

zig *n.*急转；锯齿形转角 *vi.*转弯

zag *n.*急转；急变；锯齿形转角 *vi.*急转；急变；急弯

innocuous *adj.*无害的；无伤大雅的

afield *adv.*在远方地；遥远地；远离家乡地；在田野，在野外 *adj.*远方的；遥远的；远离家乡的

Pantheon *n.*万神殿；名流群

compatriot *n.*同胞，同国人；同事，伙伴



blindside *v.*出其不意地袭击；（使）遭受意外的打击；拦腰撞上（其他车辆）

tip-off *n.*密报；警告；举报



boast of *v.* 吹牛，自夸

newbie *n.*网络新手；新兵



demarcate *vt.*划分界线；区别

arcane *adj.*神秘的，晦涩难懂的

burbling *v.*语无伦次地讲话；潺潺做声；（航空）产生气流（burble 的现在分词）；

​                *n.*潺潺的水声；（诗歌）汩汩的水声；激动人心的演讲

deliberation *n.*考虑，思考；从容，审慎；审议，商议；考虑，细想

unrivaled *adj.*无敌的；至高无上的；无比的

waylay *vt.*伏击；埋伏

concede *v.*（通常指不情愿地）承认；认（输），承认（失败）；授予，让与；让对手得分

consensus *n.*一致看法，共识

grudge *n.*怨恨，嫌隙 *v.*（因不满而）不愿意给（或允许）；嫉恨，妒忌（某人）做成（某事）

grudgingly *adv.*勉强地；不情愿地

implication *n.*可能的影响（或作用、结果）；含意，暗指；牵连，涉及

leeway *n.*余地；风压差；偏航；落后

run-of-the-mill *adj.*普通的；非精选的

run-of-the-mine *adj.*普通的，不突出的；（煤）未分类的

ironclad *adj.*装甲的；打不破的；坚固的； *n.*装甲舰

carpal *n.*腕关节；*adj.*腕关节的

carpal tunnel syndrome 腕管综合征

cumbersome *adj.*笨重的；繁琐的，复杂的；（话语或措词）冗长的

concoct *vt.*编造；调制（食物或饮品）

assortment *n.*各种各样，混合

**inferior** *adj.*次的，较差的；低等的，下级的；自卑的；（法庭，特别法庭）下级的；（商品，服务）需求量在衰退期中较之繁荣期更大的，低档的；（位置）下方的，下位的，靠下的；（字母，数字，符号）下标的；低等的；*n.*下级，（地位或成就）低于他人者；下标字母，下标数字，下标符号



**belatedly** *adv.*延迟地；延续地

**child's play** 容易干的事；轻而易举之事



**travesty** *n.*歪曲；滑稽作品；拙劣的模仿作品；*vt.*歪曲；滑稽地模仿

**wanton** *adj.*嬉戏的；繁茂的；荒唐的；无节制的；放纵的；*n.*荡妇；水性杨花的女人 *vi.*放肆；嬉戏；闲荡；*vt.*挥霍

**enumerator** *n.*人口普查员，计数员

**susceptible** *adj.*易得病的，易受影响的；（人）易受感动的，易动感情的；可能有······的，容许······的；<正式>（尤指想法或陈述）能被理解（或证明、解释）的

**nonsensical** *adj.*无意义的；荒谬的

**tuple** 美*/ˈtjʊpəl; ˈtʌpəl/*  *n.*[计] 元组，重数

**sleek ** *adj.*光滑的，光亮的；线条流畅的，造型优美的；时髦阔气的；油嘴滑舌的；*v.*使平整光亮；掩盖；打扮整洁



Usage of ***contrast***

> Contrast that with what happens in the `auto`-ized declaration for ...



get away 离开；逃脱；出发





# Introduction

> A useful heuristic to determine whether an expression is an lvalue is to ask if you
> can take its address. If you can, it typically is. If you can’t, it’s usually an rvalue.



rhs = right hand side

lhs = left hand side

move operations = move constructors, move assignment

copy operations = copy constructors, copy assignment

“…” --> narrow ellipsis

“...” --> wide ellipsis



variadic template



本书认为，***argument*** 叫作***形参***，而***parameter*** 叫作***实参***。

> In a function call, the expressions passed at the call site are the function’s **arguments**.
> The **arguments** are used to initialize the function’s **parameters**.

所以***形参*** （***argument***）永远是**lvalue**，而***实参***（***parameter*** ）可能是**lvalue**，也可能是**rvalue**。

> The distinction between **arguments** and **parameters** is important, because **parameters** are lvalues, but the **arguments** with which they are initialized may be rvalues or lvalues. 



本书中提到的**function object**，指的是重载了函数`operator()`的class。也可以直接叫这类object是**callable objects**。



lambda是一个闭包（closure）

> Function objects created through lambda expressions are known as closures



**declaration** 和 **definition** 的区别

> **Declarations** introduce names and types without giving details, such as where storage is located or how things are implemented.
>
> **Definitions** provide the storage locations or implementation details



Function signature

本书提到的function signature，指的是**函数返回值**加上**函数参数的类型**，而函数名称和参数的名称并不是function signature的一部分。

> I define a function’s signature to be the part of its declaration that specifies parameter
> and return types. Function and parameter names are not part of the signature. In the
> example above, func’s signature is **bool(const Widget&)**. 



***backport的痛苦*** 的描述方式

> Not only can they lead to future porting headaches



C++标准委员会提到的**Undefined Behavior**（UB），指的是它们的行为不可预测。

> Sometimes a Standard says that the result of an operation is undefined behavior. That
> means that runtime behavior is unpredictable.

常见的**Undefined Behavior**

- 使用`[]`对`std::vector`的越界访问
- 对未初始化的迭代器的解引用（dereferencing an uninitialized iterator）
- 发生数据竞争（engaging in a data race，即多个线程写同一块内存地址的数据）





# Chapter 1 Deducing Types



类型推导（type deduction）可能出现的地方

- In calls to function templates
- In most situations where `auto` appears
- In `decltype` expressions, and, as of C++14, where the enigmatic `decltype(auto)` construct is employed.



本章的主要内容

> It explains how template type deduction works, how auto builds on that, and how decltype goes its own way. It even explains how you can force compilers to make the results of their type deductions visible, thus enabling you to ensure that compilers are deducing the types you want them to.

- 类型推导如何工作（起作用）
- `auto`如何工作
- `decltype`如何起作用
- 如何强制编译器显式告知类型推导的结果



## Item 1: Understand template type deduction

一个（通用的）模板函数`f`的声明（定义），这里`ParamType`表示函数形参`param`的类型名称

```cpp
template<typename T>
void f(ParamType param); // A template function declarition
```

调用`f`，这里`expr`表示调用时的表达式（值）

```cpp
f(expr); // call f with some expression
         // compilers deduce T and ParamType from expr
```

在调用函数`f`时，编译器会通过`expr`来推导两个类型，`T`和`ParamType`。虽然有很多情况这两种类型最终是相同的，但也有很多情况下这两种类型是不同的。

推导类型`T`，不仅取决于`expr`表达式的类型，也取决于形参的类型`ParamType`。

> The type deduced for `T` is dependent not just on the type of `expr`, but also on the
> form of `ParamType`

事实上，情况分为三种：

- `ParamType`是一个**指针**或**引用**，但不是**万能引用**

  > `ParamType` is a pointer or reference type, but not a universal reference. 

- `ParamType` 是一个**万能引用**

  > `ParamType` is a universal reference.

- `ParamType`既不是**指针**也不是**引用**（包括**万能引用**）。

  > `ParamType` is neither a pointer nor a reference.

### 第一种情况

**`ParamType`是一个指针或引用，但不是万能引用**

这种情况下，对于类型`T`的推导原则如下。（是的！我们实际上当然是在推导类型`T`，而不是`ParamType`！，因为类型`T`推导出来之后，`ParamType`也就确定了，因为`ParamType`实际上这里指的是`T`带一个修饰关键字的变种类型，比如`const T&`）

- 首先忽略`ParamType`的引用部分（即`&`）
- 如果`expr`是一个引用，也忽略它的引用部分（即`&`）
- 按照模式匹配的办法，匹配`expr`和`ParamType`，并以此决**定类型`T`**！



#### `ParamType` - `T&`

如果`ParamType`是非`const`的引用类型，`f`函数如下，

```cpp
template<typename T>
void f(T &param);	// param is a reference
```

定义了一些变量，并且以其为表达式调用函数`f`，那么编译器就会推断出类型`T`如下

```cpp
int x = 27; // x is an int
const int cx = x; // cx is a const int
const int &rx = x; // rx is a reference to x as a const int

f(x);	// T is int, param's type is int&
f(cx);	// T is const int, param's type is const int&
f(rx);	// T is const int, param's type is const int&
```

- 调用函数`f(x)`，按照上述规则，推导过程如下
  - 忽略`ParamType`的引用部分，得到`T`
  - 此时`x`不是引用，所以略过第二条规则
  - 直接用`int`和`T`匹配，推导出`T`就是`int`（同时也推导出`ParamType`就是`T&`）
- 调用函数`f(cx)`，按照上述规则，推导过程如下
  - 忽略`ParamType`的引用部分，得到`T`
  - 此时`cx`不是引用，所以略过第二条规则
  - 直接用`const int`和`T`匹配，推导出`T`就是`const int`（同时也推导出`ParamType`就是`const int&`）
- 调用函数`f(rx)`，按照上述规则，推导过程如下
  - 忽略`ParamType`的引用部分，得到`T`
  - 此时`rx`是引用，所以忽略它的引用部分得到`const int`。
  - 直接用`const int`和`T`匹配，推导出`T`就是`const int`（同时也推导出`ParamType`就是`const intT&`）



#### `ParamType` - `const T&`

如果`ParamType`是`const`的引用类型，`f`函数如下

```cpp
template<typename T>
void f(const T &param);	// param is a reference
```

同样地有如下变量定义，和函数调用，那么编译器就会推断出类型`T`如下

```cpp
int x = 27; // x is an int
const int cx = x; // cx is a const int
const int &rx = x; // rx is a reference to x as a const int

f(x);	// T is int, param's type is const int&
f(cx);	// T is int, param's type is const int&
f(rx);	// T is int, param's type is const int&
```

这种情况下，稍有区别的是，因为已经假定了`param`的类型是`const`了，所以对于类型`T`的推导就不用再考虑`const`修饰符了。

- 调用函数`f(x)`，按照上述规则，推导过程如下
  - 忽略`ParamType`的引用部分（以及`const`修饰符），得到`T`。
  - 此时`x`不是引用，所以略过第二条规则
  - 直接用`int`和`T`匹配，推导出`T`就是`int`（同时也推导出`ParamType`就是`T&`）
- 调用函数`f(cx)`，按照上述规则，推导过程如下
  - 忽略`ParamType`的引用部分（以及`const`修饰符），得到`T`。
  - 此时`cx`不是引用，所以略过第二条规则。但同时忽略`cx`的`const`，得到`int`
  - 直接用`int`和`T`匹配，推导出`T`就是`int`（同时也推导出`ParamType`就是`const int&`）
- 调用函数`f(rx)`，按照上述规则，推导过程如下
  - 忽略`ParamType`的引用部分（以及`const`修饰符），得到`T`。
  - 此时`rx`是引用，所以忽略它的引用部分，同时也忽略`const`，得到`int`。
  - 直接用`int`和`T`匹配，推导出`T`就是`int`（同时也推导出`ParamType`就是`const intT&`）



#### `ParamType` - `T*`

如果`ParamType`是非`const`的指针类型，`f`函数如下

```cpp
template<typename T>
void f(T *param); // param is a pointer
```

有如下变量定义，和函数调用，那么编译器就会推断出类型`T`如下

```cpp
int x = 27; // x is an int
const int *px = &x; // px is a pointer to const int

f(&x);	// T is int, param's type is int*
f(px);	// T is const int, param's type is const int*
```

- 调用函数`f(&x)`，按照上述规则，推导过程如下
  - 忽略`ParamType`的指针部分，得到`T`
  - 此时`x`不是指针，所以略过第二条规则
  - 直接用`int`和`T`匹配，推导出`T`就是`int`（同时也推导出`ParamType`就是`int*`）

- 调用函数`f(px)`，按照上述规则，推导过程如下

  - 忽略`ParamType`的指针部分，得到`T`

  - 此时`px`是指针，所以忽略它的引用部分得到`const int`。

  - 直接用`const int`和`T`匹配，推导出`T`就是`const int`（同时也推导出`ParamType`就是`const int*`）



#### `ParamType` - `const T*`

如果`ParamType`是`const`的指针类型，`f`函数如下

```cpp
template<typename T>
void f(const T *param); // param is a pointer
```

有如下变量定义，和函数调用，那么编译器就会推断出类型`T`如下

```cpp
int x = 27; // x is an int
const int *px = &x; // px is a pointer to const int

f(&x);	// T is int, param's type is const int*
f(px);	// T is int, param's type is const int*
```

同样的，这种情况下，因为已经假定了`param`的类型是`const`了，所以对于类型`T`的推导就不用再考虑`const`修饰符了。

- 调用函数`f(&x)`，按照上述规则，推导过程如下
  - 忽略`ParamType`的指针部分（以及`const`修饰符），得到`T`
  - 此时`x`不是指针，所以略过第二条规则
  - 直接用`int`和`T`匹配，推导出`T`就是`int`（同时也推导出`ParamType`就是`const int*`）

- 调用函数`f(px)`，按照上述规则，推导过程如下

  - 忽略`ParamType`的指针部分（以及`const`修饰符），得到`T`

  - 此时`px`是指针，所以忽略它的引用部分，同时也忽略`const`，得到`int`。

  - 直接用`int`和`T`匹配，推导出`T`就是`int`（同时也推导出`ParamType`就是`const int*`）



### 第二种情况

**`ParamType`是一个万能引用**

#### `ParamType` - `T&&`

这种情况有些特殊，对于类型`T`的推导原则如下。

- 如果`expr`是一个左值，那么`T`和`ParamType`都会被推导为**左值引用**
  - 这是在模板类型推导中，`T`会被推导为引用的唯一一种情况
  - 尽管`ParamType`使用了像右值引用一样的声明语法，但它最终却推导成了左值引用。
- 如果`expr`是一个右值，那么就按照前面提到的第一种情况进行推导
  - 首先忽略`ParamType`的引用部分（即`&&`）
  - 如果`expr`是一个引用，也忽略它的引用部分（即`&&`）
  - 按照模式匹配的办法，匹配`expr`和`ParamType`，并以此决**定类型`T`**

这种情况下，函数`f`如下

```cpp
template<typename T>
void f(T &&param); // param is now a universal reference
```

定义了一些变量，并且以其为表达式调用函数`f`，那么编译器就会推断出类型`T`如下

```cpp
int x = 27;			// x is an int
const int cx = x;	// cx is a const int
const int &rx = x;	// rx is a reference to x as a const int

f(x);	// x is lvalue, so T is int&, param's type is also int&
f(cx);	// cx is lvalue, so T is const int&, param's type is also const int&
f(rx);	// rx is lvalue, so T is const int&, param's type is also const int&
f(27);	// 27 is rvalue, so T is int, param's type is therefore int&&
```

- 调用函数`f(x)`
  - `x`是一个左值（因为是具名变量），所以`T`被推导为`int &`，同时`ParamType`也被推导为`int &`
- 调用函数`f(cx)`
  - `cx`是一个左值（因为是具名变量），所以`T`被推导为`const int &`，同时`ParamType`也被推导为`const int &`
- 调用函数`f(rx)`
  - `rx`是一个左值引用，但同样的，因为是具名变量，所以它也是左值，所以`T`被推导为`const int &`，同时`ParamType`也被推导为`const int &`

- 调用函数`f(27)`
  - `27`是一个右值，所以按照前面提到的第一种情况推导
  - 首先忽略`T&&`的引用部分，得到`T`
  - 其次`27`是右值，但不是引用（而是`int`）
  - 直接用`int`和`T`匹配，得到`T`就是`int`，所以得到`ParamType`就是`int &&`



### 第三种情况

**`ParamType`既不是指针，也不是任何一种引用**

#### `ParamType` - `T`

这种情况下，处理的是**值传递**（pass-by-value），那么`param`就是一个传入值的拷贝（新对象）。

推导规则如下，

- 如果`expr`是一个引用，忽略它的引用部分
- 如果`expr`同时还是`const`或`volatile`，忽略它的`const`或`volatile`部分

这种情况下，函数`f`如下

```cpp
template<typename T>
void f(T param); // param is now passed by value
```

定义了一些变量，并且以其为表达式调用函数`f`，那么编译器就会推断出类型`T`如下

```cpp
int x = 27;			// as before
const int cx = x;	// as before
const int& rx = x;	// as before
const char* const p = "Fun with pointers" // ptr is const pointer to const object

f(x);	// T's and param's types are both int
f(cx);	// T's and param's types are again both int
f(rx);	// T's and param's types are still both int
f(p);	// T's and param's types are const int*
```

- 调用函数`f(x)`
  - `x`不是引用
  - `x`既也不是`const`，也不是`volatile`
  - 因此直接用`x`的类型`int`和`T`做匹配，所以推导出`T`就是`int`，因此`param`的类型也是`int`（非`const`）
- 调用函数`f(cx)`
  - `x`不是引用
  - `x`是`const`，但不是`volatile`，所以只用忽略`const`
  - 因此直接`int`和`T`做匹配，所以推导出`T`就是`int`，因此`param`的类型也是`int`（非`const`）
- 调用函数`f(rx)`
  - `x`是引用，所以忽略它的引用部分
  - `x`是`const`，但不是`volatile`，所以只用忽略`const`
  - 因此直接`int`和`T`做匹配，所以推导出`T`就是`int`，因此`param`的类型也是`int`（非`const`）
- 调用函数`f(p)`
  - `x`不是引用
  - `x`是`const`，这个`const`指的是这个`pointer`不能指向其他的内存地址，即这个`pointer`本身是`const`，所以忽略它（因为值传递就是拷贝）。不是`volatile`所以不管`volatile`。
  - 因此直接`const char*`和`T`做匹配，所以推导出`T`就是`const char*`，因此`param`的类型也是`const char*`，即指针是指向一个内容不可以被修改的地址，但这个指针本身是可以指向其它内存地址的。



### 如果实参是数组

定义数组变量

```cpp
const char name[] = "J. P. Briggs";	// name's type is const char[13]
const char * ptrToName = name;		// array decays to pointer
```

首先，在C中，如果用一个数组去初始化一个指针，那么指针就指向数组的第一个元素，这叫作**array decays**。

这个**array-to-pointer decay rule**，和这里讨论的类型推导无关，是C的特性。

类似的，如果函数的参数是一个数组，那么实际上下面两种函数声明是等价的

```cpp
void myFunc(int param[]);
void myFunc(int* param); // same function as above
```

这实际上表明，指针和数组实际上是等价的。



函数模板`f`声明如下，调用函数并传入数组作为参数

```cpp
template<typename T>
void f(T param); // template with by-value parameter

f(name); // what types are deduced for T and param?
```

此时，`T`被推导为`const char*`。这是由于传入的数组，被等价地认为是一个指针，然后再进行类型推导。



函数模板`f`声明如下，调用函数并传入数组作为参数

```cpp
template<typename T>
void f(T &param); // template with by-value parameter

f(name); // what types are deduced for T and param?
```

由于声明了引用`&`的缘故，此时，`T`被推导为`const char [13]`，而不再推导为指针了，同时`ParamType`变为`const char (&)[13]`。



利用这种特性，可以通过声明成`T&`，在编译期间计算得到一个数组的长度。

```cpp
// Return size of an array as a compile-time constant. (The
// array parameter has no name, because we care only about
// the number of elements it contains.)
template<typename T, std::size_t N> 
constexpr std::size_t arraySize(T (&)[N]) noexcept {
    return N;
}
```

使用举例

```cpp
int keyVals[] = { 1, 3, 7, 9, 11, 22, 35 }; // keyVals has 7 elements
int mappedVals[arraySize(keyVals)]; // so does mappedVals

std::array<int, arraySize(keyVals)> mappedVals; // mappedVals' size is 7
```



### 如果实参是函数

同样地，如果是函数作为参数，也会和数组的array-to-pointer decay rule一样，函数会退化为函数指针。

```cpp
void someFunc(int, double); // someFunc is a function; type is void(int, double)

template<typename T>
void f1(T param); // in f1, param passed by value

template<typename T>
void f2(T &param); // in f2, param passed by ref

f1(someFunc); // param deduced as ptr-to-func; type is void (*)(int, double)
f2(someFunc); // param deduced as ref-to-func; type is void (&)(int, double)
```

`f1`声明的是值传递，如果函数作为参数传入，会推导出来类型`T`是函数指针：`void (*)(int, double)`

`f2`声明的是引用传递，如果函数作为参数传入，会推导出来类型`T`是函数引用：`void (&)(int, double)`



### Things To Remember

> Things to Remember
>
> - During template type deduction, arguments that are references are treated as non-references, i.e., their reference-ness is ignored.
> - When deducing types for universal reference parameters, lvalue arguments get special treatment.
> - When deducing types for by-value parameters, `const` and/or`volatile` arguments are treated as non-`const` and non-`volatile`.
> - During template type deduction, arguments that are array or function names decay to pointers, unless they’re used to initialize references.



## Item 2: Understand auto type deduction

`auto` 类型推导就是`template` 类型推导（有一个例外）

> `auto` type deduction ***is*** template type deduction.
>
> There’s a direct mapping between `template` type deduction and `auto` type deduction.
>
> Deducing types for auto is, with only one exception, the same as deducing types for templates.



在Item 1中，（通用的）函数模板和对应的调用分别如下

```cpp
template<typename T>
void f(ParamType param); // A template function declarition

f(expr); // call f with some expression
         // compilers deduce T and ParamType from expr
```

而编译器负责推导类型`T`以及类型`ParamType`。

对应于`auto`的类型推导，`auto`扮演了`T`的角色，而对应变量的***type specifier***扮演了`ParamType`的角色，例如

```cpp
auto x = 27;		// auto is T, type specifier is auto (ParamType is auto)
const auto cx = x;	// auto is T, type specifier is const auto (ParamType is const auto)
const auto& rx = x;// auto is T, type specifier is const auto& (ParamType is const auto&)
```

为了推导类型，编译器就好像假设存在以下对应的`template`函数（和相应的函数调用）一样

```cpp
template<typename T> 		// conceptual template for
void func_for_x(T param);	// deducing x's type
func_for_x(27);				// conceptual call: param's
							// deduced type is x's type

template<typename T>				// conceptual template for
void func_for_cx(const T param);	// deducing cx's type
func_for_cx(x);						// conceptual call: param's
									// deduced type is cx's type

template<typename T>				// conceptual template for
void func_for_rx(const T& param);	// deducing rx's type
func_for_rx(x);						// conceptual call: param's
									// deduced type is rx's type
```



### `auto`类型推导的情况

在Item1中，对template函数，根据`ParamType`把推导类型的情况分成了三种。

类似的，对于`auto` 可以根据 ***type specifier*** 把情况也分成三种。

- **type specifier 是一个指针或引用，但不是万能引用**
- **type specifier 是万能引用**
- **type specifier 既不是指针也不是任何一种引用**

> - Case 1: The type specifier is a pointer or reference, but not a universal reference.
> - Case 2: The type specifier is a universal reference.
> - Case 3: The type specifier is neither a pointer nor a reference.



> As you can see, auto type deduction works like template type deduction. They’re essentially two sides of the same coin.



三种情况对应的例子

```cpp
// Case 1: A reference/pointer, but not a universal reference
const auto& rx = x;

// Case 2: A universal reference
auto&& uref1 = x;	// x is int and lvalue, so uref1's type is int&
auto&& uref2 = cx;	// cx is const int and lvalue, so uref2's type is const int&
auto&& uref3 = 27;	// 27 is int and rvalue, so uref3's type is int&&

// Case 3: Neither a pointer nor a reference of any kind
auto x = 27;
const auto cx = x;
```



和Item1中相对应的，如果是数组或者函数的时候，会发生同样的 array-to-pointer decay和function-to-pointer decay rule。

```cpp
const char name[] = "R. N. Briggs"; // name's type is const char[13]

auto arr1 = name; // arr1's type is const char*
auto& arr2 = name; // arr2's type is const char (&)[13]

void someFunc(int, double); // someFunc is a function; type is void(int, double)

auto func1 = someFunc; // func1's type is void (*)(int, double)
auto& func2 = someFunc; // func2's type is void (&)(int, double)
```





### `auto`推导和`template`推导唯一的不同

#### `auto`的几种初始化情况

例如，可以如下定义一个`int`值，虽然形式不同，但值都是一样的：`int`。

```cpp
int x1 = 27;	// C++98
int x2(27);		// C++98
int x3 = { 27 };	// C++11
int x4{ 27 };		// C++11
```

如果使用`auto`关键字替换上面的`int`，得到下面的定义（可以编译通过）

```cpp
auto x1 = 27;		// type is int, value is 27
auto x2(27);		// ditto
auto x3 = { 27 };	// type is std::initializer_list<int>, value is { 27 }
auto x4{ 27 };		// type is int, in win7, MSYS2, g++ version 12.1.0
```

但前面两个（`x1`，`x2`）的类型被推导为`int`，而后面的（`x3`）被推断为`std::initializer_list<int>`，其值是`{27}`。而最后的`x4`，实际上也被推导为`int`，而并不是`std::initializer_list<int>`。

**注意，经过验证，发现`x4`实际上也被推导为`int`，而并不是`std::initializer_list<int>`。环境是win7, MSYS2, g++ version 12.1.0。**



需要注意的两点

- 如果在花括号里面的值不是同一种类型的话，会编译失败

```cpp
auto x5 = { 1, 2, 3.0 }; // error! can't deduce T for std::initializer_list<T>
```

- 对于上面的`x3`，`x4`和`x5`，它们同时发生了两种类型推导
  - 因为使用了花括号（braces），所以它们必须被推导为`std::initializer_list`
  - 因为`std::initializer_list<T>`是类模板，所以类型`T`也必须要被推导



#### 唯一的不同

简单来说，唯一的区别是：

**如果使用列表初始化，`auto`会推导为`std::initializer_list<TypeName>`类型，而`template`的推导却不能推断出来`std::initializer_list<TypeName>`类型。**

> The treatment of braced initializers is the only way in which auto type deduction and template type deduction differ. 

（这里的`TypeName`是指某个确定的类型名）

换句话说，使用同一个列表（braced initializer），去初始化一个使用`auto`声明的变量，会推断为一个`std::initializer_list`，但是用同样的这个列表，传递给一个模板函数，推断会失败。

> So the only real difference between auto and template type deduction is that auto assumes that a braced initializer represents a std::initializer_list, but template type deduction doesn’t.

```cpp
auto x = { 11, 23, 9 }; // x's type is std::initializer_list<int>

template<typename T>	// template with parameter
void f(T param);		// declaration equivalent to x's declaration

f({ 11, 23, 9 });		// error! can't deduce type for T
```

上面的例子中，使用用一个列表`{ 11, 23, 9 }`，`auto`推断出来了`std::initializer_list<int>`，而`T`却推断失败了。

如果想要使`T`推断成功，需要把`ParamType`声明称为如下的形式

```cpp
template<typename T>
void f(std::initializer_list<T> initList);

f({ 11, 23, 9 }); // T deduced as int, and initList's type is std::initializer_list<int>
```



#### `auto` 在C++14 中的特点

在C++14中，

- 允许声明函数的返回值是`auto`，并进行类型推导
- 允许lambda中形参声明为`auto`，并进行类型推导

但上面提到的两种语法，使用的是模板类型推导（template type deduction），而不是`auto`类型推导。

也就是说，如果传递一个列表，上面两种情况下，`auto`进行类型推导会失败。

```cpp
// C++14, return type is auto which is permitted
auto createInitList() {
	return { 1, 2, 3 }; // error!! can't deduce type
} // for { 1, 2, 3 }


// C++14, lambda's paramter can be auto
std::vector<int> v;
auto resetV = &v](const auto& newValue) { v = newValue; }; // C++14
resetV({ 1, 2, 3 }); // error!! can't deduce type
// for { 1, 2, 3 }
```



#### Things to Remember

> - `auto` type deduction is usually the same as template type deduction, but `auto` type deduction assumes that a braced initializer represents a `std::initializer_list`, and template type deduction doesn’t.
> - `auto` in a function return type or a lambda parameter implies template type deduction, not `auto type` deduction.





## Item 3: Understand `decltype`

关键字`decltype`可以告知我们一个名字或者一个表达式的类型。

### `decltype` 用法示例

`decltype`的一些例子

```cpp
const int i = 0;			// decltype(i) is const int
bool f(const Widget &w);	// decltype(w) is const Widget&
							// decltype(f) is bool(const Widget&)
struct Point {
	int x, y;				// decltype(Point::x) is int
};							// decltype(Point::y) is int

Widget w;					// decltype(w) is Widget
if (f(w)) {}				// decltype(f(w)) is bool

template<typename T>		// simplified version of std::vector
class vector {
public:
	// ...
	T& operator[](std::size_t index);
	// ...
};
vector<int> v;				// decltype(v) is vector<int>

if (v[0] == 0) 				// decltype(v[0]) is int&
```



### Trailing Return Type优点

`decltyp`在C++11中最主要的用法，也许是当函数返回值的类型取决于其参数时，声明它（一个函数返回值）的类型

> In C++11, perhaps the primary use for `decltype` is declaring function templates where the function’s return type depends on its parameter types. 

比如下面的例子，返回值是输入参数的`[]`操作返回值，那么就可以使用所谓的**Trailing Return Type**来声明其返回值的类型。

```cpp
template<typename Container, typename Index>
auto authAndAccess(Container &c, Index i) -> decltype(c[i]) {
	authenticateUser();
	return c[i];
}
```

在使用**Trailing Return Type**来声明函数的返回值的时候，函数名前面的`auto`和类型推导无关，这个`auto`只是用来说明C++11的**Trailing Return Type**被用来声明函数返回值类型。



**trailing return type**的优点

- C++11中就可以使用
- 优点是因为类型后置了，所以函数参数可以在类型中使用

> Rather, it indicates that C++11’s *trailing return type* syntax is being used, i.e., that the function’s return type will be declared following the parameter list (after the “->”). A trailing return type has the  advantage that the function’s parameters can be used in the specification of the return type.



### 使用`decltype`的潜在陷阱

#### 陷阱在函数返回值推导

在C++11中可以使用**Trailing Return Type**来利用`decltype`声明返回值类型

```cpp
template<typename Container, typename Index>
auto authAndAccess(Container &c, Index i) -> decltype(c[i]) {
	authenticateUser();
	return c[i];
}
```

可以使用上面的定义来修改容器中的元素

```cpp
std::vector<int> ivec{0, 1, 2, 3, 4, 5};
authAndAccess(ivec, 0) = 100;
```



在C++14中，支持省略**Trailing Return Type**，而直接由`auto`来推导函数返回值类型

```cpp
template<typename Container, typename Index>
auto authAndAccess(Container &c, Index i) {
	authenticateUser();
	return c[i];
}
```

但此时如果使用上述函数定义，那么如下的使用就会编译失败

```cpp
std::vector<int> ivec{0, 1, 2, 3, 4, 5};
authAndAccess(ivec, 0) = 100; // fail to compile if use the definition above
```

原因是，在C++14中，`auto`在作为函数返回值进行类型推导时，遵循的依据和进行`template`类型推导时的相同，即如果返回值中带有引用（reference-ness，`&`），那么这个引用就会被忽略，然后进行推导。

这就导致上面的函数实际上推导出来的是，返回一个新的对象，而它是一个rvalue，那么给一个右值赋值，就会产生编译错误。

为了避免这个问题，在C++14中，可以使用`decltype(auto)`来解决。这里

- `auto`是声明这里的类型需要被推导
- `decltype`是说明在推导的过程中，采用的是`decltype`的rule

> `auto` specifies that the type is to be deduced, and `decltype` says that `decltype` rules should be used during the deduction.

```cpp
template<typename Container, typename Index>
decltype(auto) authAndAccess(Container &c, Index i) {
	authenticateUser();
	return c[i];
}
```



上面几个函数中的 `c` 都是左值引用，所以必须绑定到左值上。

为了能够绑定到右值，可以使用万能引用，而且为了保留返回值的引用特性（reference-ness），需要使用完美转发（perfect forwarding：`std::forward`）

```cpp
// Need C++14 support
template<typename Container, typename Index>
decltype(auto) authAndAccess(Container &&c, Index i) {
	authenticateUser();
	return std::forward<Container>(c)[i];
}
// C++11 support is enough
template<typename Container, typename Index>
auto authAndAccess(Container &&c, Index i) -> decltype(std::forward<Container>(c)[i]) {
	authenticateUser();
	return std::forward<Container>(c)[i];
}

// get_temp_vec() returns an rvalue
auto val0 = authAndAccess(get_temp_vec(), 1);
```

此外，`decltype(auto)`还可以用在其它地方

```cpp
Widget w;
const Widget& cw = w;
auto myWidget1 = cw;	// auto type deduction: myWidget1's type is Widget
decltype(auto) myWidget2 = cw;	// decltype type deduction:
								// myWidget2's type is const Widget&
```



#### 陷阱在左值表达式

> if an `lvalue` expression other than a name has type `T`, `decltype` reports that type as `T&`.



使用`decltype(x)`和`decltype((x))`，得到的类型是不同的

```cpp
int x = 0;	// decltype(x) is int
			// decltype((x)) is int&
```

这样的情况在C++14中的函数返回值为`auto`的时候，需要特别注意。

在下面的`f2`中，实际上的返回值是`int&`类型，所以它实际上返回了一个local variable的引用，这实际上是应该避免的。

```cpp
decltype(auto) f1() {
	int x = 0;
	return x; // decltype(x) is int, so f1 returns int
}
decltype(auto) f2() {
	int x = 0;
	return (x); // decltype((x)) is int&, so f2 returns int&
}
```



Things to Remember

> - `decltype` almost always yields the type of a variable or expression without any modifications.
> - For lvalue expressions of type T other than names, `decltype` always reports a type of `T&`.
> - C++14 supports `decltype(auto)`, which, like auto, deduces a type from its initializer, but it performs the type deduction using the `decltype` rules.







## Item 4: Know how to view deduced types



本节中指出，可以使用`boost::type_index`中的类来获取类型的名称，并且可以使用对应的函数获得可读性较强的名称字符串。

- 头文件：`boost/type_index.hpp`
- 类：`boost::typeindex::type_id_with_cvr<T>`
- 函数：`boost::typeindex::type_id_with_cvr<T>().pretty_name()`

```cpp
#include <boost/type_index.hpp>
template<typename T>
void f(const T& param) {
	using std::cout;
	using boost::typeindex::type_id_with_cvr;
	// show T
	cout << "T = "
		<< type_id_with_cvr<T>().pretty_name()
		<< '\n';
	// show param's type
	cout << "param = "
		<< type_id_with_cvr<decltype(param)>().pretty_name()
		<< '\n';
}
```





# Chapter 2 `auto`



## Item 5: Prefer `auto` to explicit type declarations



> The type of a closure is known only to the compiler, hence can’t be written out.



### `auto`的优点

- 避免未初始化的值（`auto`定义变量必须初始化）

```cpp
int x1;			// potentially uninitialized
auto x2;		// error! initializer required
auto x3 = 0;	// fine, x's value is well-defined
```

- 可以表示只有编译器才知道的类型（**闭包closure**）
  - lambda可以包含一个闭包
  - `std::function` 也可以包含一个闭包

```cpp
auto derefUPLess =							// comparison func.
	[](const std::unique_ptr<Widget>& p1,	// for Widgets
	const std::unique_ptr<Widget>& p2)		// pointed to by
	{ return *p1 < *p2; };					// std::unique_ptrs

// Need C++14 support
auto derefLess =							// C++14 comparison
	[](const auto& p1, const auto& p2)		// function for values pointed
	{ return *p1 < *p2; };					// to by anything pointer-like
```







> What’s a `std::function` object?
>
> `std::function` is a template in the C++11 Standard Library that generalizes the idea of a function pointer. Whereas function pointers can point only to functions, however, `std::function` objects can refer to any callable object, i.e., to anything that can be invoked like a function. 
>
> Just as you must specify the type of function to point to when you create a function pointer (i.e., the signature of the functions you want to point to), you must specify the type of function to refer to when you create a `std::function` object. 



### `std::function`对象是什么？

- `std::function` 是C++11标准库中的一个模板（类），目的是使函数指针的思想通用化
- `std::function` 对象可以引用任何可调用（callable）的对象，而函数指针只能指向函数
- `std::function` 对象的初始化，是通过指明模板参数，即函数的signature来实现的（与创建函数指针类似）



### `auto`和`std::function`包含闭包时的差异

除了语法的详细程度、以及需要重复参数的类型名称，`std::function`和`auto`实际上是有一些差别的。

简单来说就是`std::function`比`auto`包含闭包时，要占用更多内存，而且调用运行比较慢。

- 使用`auto`声明的变量，它的类型和它所包含的的闭包类型一致。它所占用的内存空间大小，实际上就是它所包含的闭包占用的内存空间大小。
- 使用`std::function`声明的变量，它实际上是`std::function`这个template类的一个实例，这个实例包含了一个闭包。所以`std::function`对于任意一个函数signature，它所占用的内存大小是固定的。这样导致的问题是它所包含的闭包也许要使用更多的内存空间，此时`std::function`就要在堆上申请更多的内存来存储这个闭包。由于实现的细节和内联的限制，通过`std::function`来调用一个闭包，几乎必然比通过调用`auto`声明的对象要**慢，而且占用更多内存（还有out-of-memory的exception）**。



> An `auto`-declared variable holding a closure has the same type as the closure, and as such it uses only as much memory as the closure requires. The type of a `std::function`-declared variable holding a closure is an instantiation of the `std::function` template, and that has a fixed size for any given signature. This size may not be adequate for the closure it’s asked to store, and when that’s the case, the std::function constructor will allocate heap memory to store the closure.



### Advantages of `auto`

- avoidance of uninitialized variables
- verbose variable declarations
- the ability to directly hold closures
- ability to avoid “type shortcuts” (says by Scott Meyers)



### `std::unordered_map`的迭代器的返回值

`std::unordered_map`中，key的部分实际上是`const`。

即`std::unordered_map`中存储的元素，在插入map之后，如果再次从map中取得（访问），得到的类型实际上是`std::pair<const KeyType, ValueType>`，这里的`KeyType`和`ValueType`分别是key的类型和value的类型。

所以，如果是在使用`auto`声明的`for`循环中，编译器可以帮助避免这个临时变量的问题。





## Item 6: Use the explicitly typed initializer idiom when `auto` deduces undesired types



### `auto` with proxy classes : operator `[]` in `std::vector<bool>`

一般地，`std::vector<T>::operator[]`都会返回容器中对应索引元素的引用（即T&），但`std::vector<bool>`是例外，它的`operator[]`返回一个新的object，类型是一个class `std::vector<bool>::reference`，它可以转换为`bool`类型，或者由`bool`类型转换而来。

这个class是定义在`std::vector<bool>`中。

```cpp
class vector<bool>::reference {
  friend class vector;
  reference() noexcept;                                 // no public constructor
public:
  ~reference();
  operator bool () const noexcept;                      // convert to bool
  reference& operator= (const bool x) noexcept;         // assign from bool
  reference& operator= (const reference& x) noexcept;   // assign from bit
  void flip();                                          // flip bit value.
};
```

所以，如果使用类似`bool b = bvec[0]`的操作，`bvec[0]`会返回一个`std::vector<bool>::reference`，然后它被隐式地转换为一个`bool`，而不是一个`bool&`。

这个问题产生的原因是，`std::vector<bool>`是`std::vector`的一个特化template，它内部使用了`bits`来存储这些对应的`bool`值（一个`bit`对应一个`bool`），但**C++禁止引用`bits`**，所以就不能像正常的`std::vector`一样，`operator[]`返回`T&`，所以引入了这个class，来模拟`bool&`的行为。



### 使用`static_cast`帮助`auto`进行类型推导

为了防止`auto`在某些情况下被Proxy Class所诱导而推导出所需的类型，可以使用`static_cast`来帮助编译器进行正确推导出我们想要的类型。

如书中所述，下面的代码在`auto`处会被推导称为一个`std::vector<bool>::reference`。

```cpp
std::vector<bool> features(const Widget& w);

Widget w;
auto highPriority = features(w)[5]; // is w high priority?
processWidget(w, highPriority); // process w in accord with its priority
```

这个`std::vector<bool>::reference`就是一个proxy class，它的行为取决于它的实现。

书中提到了一种可能的实现：使用一个指针指向`bits`，并加上一个offset，以便找到对应的`bit`。

在这样的实现下，上面的代码就回产生undefined behavior。

原因是`features(w)`返回一个临时的`std::vector<bool>`，进而`features(w)[5]`返回一个`std::vector<bool>::reference`，然后再赋值给`highPriority`并由编译器来推导其类型，而此时临时的`std::vector<bool>`已经被销毁，这就导致`std::vector<bool>::reference`中的指针变成了一个dangling pointer，那么就可能会出问题。

解决这个问题的办法，是使用`static_cast`，它显式地（在编译期间）将起转换成`bool`（`std::vector<bool>::reference`提供的`bool`转换），然后编译器再将`highPriority`推导为`bool`类型。

```cpp
auto highPriority = static_cast<bool>(features(w)[5]);
```



> some classes in C++ libraries employing a technique known as expression templates

> As a general rule, “invisible” proxy classes don’t play well with `auto`



### 使用`static_cast`类显式说明正在做特意的转换

如书中所述，可以使用`static_cast`，除了帮助转换proxy class以便`auto`正确推导外，还可以利用它，显式说明当前正在做特意的转换，以便引起注意。

```cpp
double calcEpsilon(); // return tolerance value

float ep = calcEpsilon(); // impliclitly convert: double → float
auto ep = static_cast<float>(calcEpsilon()); // Use static_cast + auto
```



Things to Remember

> - “Invisible” proxy types can cause `auto` to deduce the “wrong” type for an initializing expression.
>
> - The explicitly typed initializer idiom forces `auto` to deduce the type you want it to have.





# Chapter 3 Moving to Modern C++

C++11和C++14值得大书特书的突出特性

- auto

- smart pointers

- move semantics

- lambdas

- concurrency

需要解答并掌握背后原因的结果问题

- When should you use braces instead of parentheses for object creation?
  - 创建对象时，为什么应该使用花括号（`{}`）而不是圆括号（`()`）
- Why are alias declarations better than `typedef`s?
  - 为什么`alias`声明要比`typedef`更好？
- How does `constexpr` differ from `const`?
  - `constexpr`和`const`相比，有何不同？
- What’s the relationship between `const` member functions and thread safety? 
  - `const`成员函数和线程安全之间有什么关系？





## Item 7: Distinguish between `()` and `{}` when creating objects

C++中，初始化对象的语法主要有如下几种

- 括号（`()`，parentheses）
- 等号（`=`，equal sign）
- 花括号（`{}`，curly braces）
- 等号+花括号（`= {}`，equals-sign-plus-braces）

```cpp
int x(0);		// initializer is in parentheses
int y = 0;		// initializer follows "="
int z{ 0 };		// initializer is in braces
int z = { 0 };	// initializer uses "=" and braces
```

C++中通常把”等号+花括号“（equals-sign-plus-braces）的形式等同于花括号

其中，花括号是由C++11引入的，称为**uniform initialization**，Scott Meyers更喜欢叫它**braced initialization**。



### braced initialization为何uniform？

几个特点

- 可以指定一个集合来初始化容器
  - C++98做不到
- 可以用来指定类数据成员的默认初始化值
  - 等号`=`也可以用于此用途，但圆括号`()`不行
- 可以用来初始化uncopyable objects （比如`std::atomic`）
  - 圆括号`()`也可以用于此用途，但等号`=`不行

由此可见，`{}`花括号初始化为什么叫做**uniform initialization**了

```cpp
std::vector<int> v{ 1, 3, 5 }; // v's initial content is 1, 3, 5

class Widget {
	private:
	int x{ 0 };	// fine, x's default value is 0
	int y = 0;	// also fine
	int z(0);	// error!!!
};

std::atomic<int> ai1{ 0 };	// fine
std::atomic<int> ai2(0);	// fine
std::atomic<int> ai3 = 0;	// error!!!
```



### 关于类的数据成员的默认值

在C++11中，类的成员函数可以使用等号或花括号来设定成员变量的默认值，这可以保证当这些成员没有被构造函数所初始化时，就能有默认值的设定。但如果这些成员在构造函数（默认构造、拷贝构造等等）被初始化了，那么这些在定义成员变量时的默认值就会被覆盖，而使用在构造函数时所初始化的值。



### 花括号初始化的优点和缺点

#### 优点

- 防止类型范围缩减转换（**narrowing conversions**）
- 防止“最烦人解析”（**most vexing parse**）

#### 缺点

- 当存在参数为`std::initializer_list`的构造函数时，可能导致非预期的重载构造函数被调用

#### 优缺点的例子

关于第一个**优点**，实际上是说用一个类型范围较大的值去初始化一个范围类型较小的值，编译会失败

```cpp
double x = 0, y = 1, z = 2;
int sum1{ x + y + z };	// error! sum of doubles may not be expressible as int
int sum2(x + y + z);	// okay (value of expression truncated to an int)
int sum3 = x + y + z;	// ditto
```

第二个**优点**，实际上是说，在调用默认构造函数（或者调用有默认值的构造函数而没有传参）时，编译器无法区分到底是在调用一个构造函数，还是在声明一个函数（因为看起来没有任何区别）。而使用花括号初始化，就能避免这个问题。

```cpp
Widget w1(10);	// call Widget ctor with argument 10
Widget w2();	// most vexing parse! declares a function
				// named w2 that returns a Widget!
Widget w3{}; // calls Widget ctor with no args
```



关于**缺点**，当没有参数为`std::initializer_list`的构造函数时，花括号和圆括号初始化会得到一致的结果

```cpp
class Widget {
public:
	Widget(int i, bool b); // ctors not declaring
	Widget(int i, double d); // std::initializer_list params
};
Widget w1(10, true);	// calls first ctor
Widget w2{10, true};	// also calls first ctor
Widget w3(10, 5.0);		// calls second ctor
Widget w4{10, 5.0};		// also calls second ctor
```

但是当存在参数为`std::initializer_list`的构造函数时，只要哪怕存在一种**类型转换的可能**，花括号和初始化会就会调用参数为`std::initializer_list`的重载构造函数，但这会导致一些意外情况发生。

这里说的至少一种**类型转换的可能**，包括narrowing conversion。（尽管花括号初始化禁止narrowing conversion，但编译器确实会这么做，并最终导致编译失败，下面的第三个例子说明了这个问题）



比如下面的第一个例子，花括号初始化时，发现`10`、`true`和`5`都能转换为`long double`（花括号初始化不允许narrowing conversion，但允许向范围更大的类型转换），那么就会将它们转换为`long double`，并调用带有参数为`std::initializer_list`的重载构造函数，但事实上，这两个重载函数调用，并不是最佳的匹配。

```cpp
class Widget {
public:
	Widget(int i, bool b); // ctors not declaring
	Widget(int i, double d); // std::initializer_list params
    Widget(std::initializer_list<long double> il); // added
};

Widget w1(10, true); // uses parens and, as before, calls first ctor
Widget w2{10, true}; // uses braces, but now calls std::initializer_list ctor
                     // (10 and true convert to long double)
Widget w3(10, 5.0);  // uses parens and, as before, calls second ctor
Widget w4{10, 5.0};  // uses braces, but now calls std::initializer_list ctor
                     // (10 and 5.0 convert to long double)
```

下面的第二个例子说明了，甚至连copy-ctor和move-ctor都存在被“劫持”的可能（因为object重载了一个转换为`float`的运算符，导致编译器发现可以从`float`向`long double`发生类型转换，从而调用参数为`std::initializer_list`的重载构造函数，但这并不是所希望的）

```cpp
class Widget {
public:
	Widget(int i, bool b); // as before
	Widget(int i, double d); // as before
	Widget(std::initializer_list<long double> il); // as before
	operator float() const; // convert to float
};

Widget w5(w4);	// uses parens, calls copy ctor
Widget w6{w4};	// uses braces, calls std::initializer_list ctor
                // (w4 converts to float, and float converts to long double)
Widget w7(std::move(w4)); // uses parens, calls move ctor
Widget w8{std::move(w4)}; // uses braces, calls std::initializer_list ctor
                          // (for same reason as w6)
```

下面的第三个例子说明了，在极端情况下，甚至可能因为编译器倾向选择带有`std::initializer_list`的重载构造函数，而导致最终编译失败。（原因是编译器发现存在带有`std::initializer_list`的重载构造函数，而又使用了花括号初始化，并且发现从`int`（`10`）或`double`（`5.0`）向`bool`转换是可能的（narrowing conversion），从而调用它，但是这是narrowing conversion，而花括号初始化禁止narrowing conversion，从而最终导致编译失败）

```cpp
class Widget {
	public:
	Widget(int i, bool b); // as before
	Widget(int i, double d); // as before
	Widget(std::initializer_list<bool> il); // element type is now bool
                                            // no implicitconversion funcs
}; 

Widget w{10, 5.0}; // error!!! requires narrowing conversions
```



所以只有当没有发生类型转换的可能时，编译器才考虑其他重载的构造函数。

这里编译器会发现不能从`int`（`10`）或`double`（`5.0`）或`bool`（`true`）向`std::string`发生类型转换，所以最终编译器会找其他最佳匹配的重载构造函数。

```cpp
class Widget {
public:
	Widget(int i, bool b); // as before
	Widget(int i, double d); // as before
    
	// std::initializer_list element type is now std::string
	Widget(std::initializer_list<std::string> il);// no implicit conversion funcs
};

Widget w1(10, true); // uses parens, still calls first ctor
Widget w2{10, true}; // uses braces, now calls first ctor
Widget w3(10, 5.0); // uses parens, still calls second ctor
Widget w4{10, 5.0}; // uses braces, now calls second ctor
```



### 默认构造函数和空的`std::initializer_list`构造函数

如果既有默认构造函数，又有一个带有`std::initializer_list`的重载构造函数，那么调用花括号初始化对象时，如果花括号里面是空的，那么调用那个构造函数？

答案是默认构造函数。

这里编译器把空的花括号认为是没有参数，而不是一个空的`std::initializer_list`。如果想要调用一个空的`std::initializer_list`来调用带有`std::initializer_list`参数的重载构造函数，那么就把`{}`（表示一个空的`std::initializer_list`）放到一个圆括号中（即`({})`）或者花括号中（`{{}}`）。见下面的例子。

```cpp
class Widget {
	public:
	Widget(); // default ctor
	Widget(std::initializer_list<int> il); // std::initializer_list ctor
                                           // no implicit conversion funcs
};
Widget w1; // calls default ctor
Widget w2{}; // also calls default ctor
Widget w3(); // most vexing parse! declares a function!
Widget w4({}); // calls std::initializer_list ctor with empty list
Widget w5{{}}; // ditto
```



### `vector`中经常碰到的区别

在`std::vector`构造时，经常会碰到使用圆括号和花括号会导致不同初始化的问题，这是由于`std::vector`有一个接受两个参数的构造函数（参数为个数和每个元素的值），但这会导致使用圆括号和花括号初始化对象，创建为完全不同的两个`std::vector`。

```cpp
std::vector<int> v1(10, 20); // use non-std::initializer_list ctor: create 10-element
                             // std::vector, all elements have value of 20
std::vector<int> v2{10, 20}; // use std::initializer_list ctor: create 2-element 
                             // std::vector, element values are 10 and 20
```

Scott Meyers提到vector里面的这种设计，后来被认为是错误的。



Scott Meyers提到这两种初始化方式的拥趸的观点，他建议选其中一种，并保持一致即可

> Braces-by-default folks are attracted by their unrivaled breadth of applicability, their prohibition of narrowing conversions, and their immunity to C++’s most vexing parse. Such folks understand that in some cases (e.g., creation of a std::vector with a given size and initial element value), parentheses are required. On the other hand, the go-parentheses-go crowd embraces parentheses as their default argument delimiter. They’re attracted to its consistency with the C++98 syntactic tradition, its avoidance of the auto-deduced-a-`std::initializer_list` problem, and the knowledge that their object creation calls won’t be inadvertently waylaid by `std::initializer_list` constructors. They concede that sometimes only braces will do (e.g.,when creating a container with particular values).There’s no consensus that either approach is better than the other, so my advice is to pick one and apply it consistently.



### Things to Remember

> - Braced initialization is the most widely usable initialization syntax, it prevents narrowing conversions, and it’s immune to C++’s most vexing parse.
>
> - During constructor overload resolution, braced initializers are matched to `std::initializer_list` parameters if at all possible, even if other constructors offer seemingly better matches.
>
> - An example of where the choice between parentheses and braces can make a significant difference is creating a `std::vector<numeric type>` with two arguments.
>
> - Choosing between parentheses and braces for object creation inside templates can be challenging.





## Item 8: Prefer `nullptr` to `0` and `NULL`

### `0` and `NULL`

理论上，当在需要指针的时候，如果编译器发现只有`0`可以使用，那么它会（不情愿地）把`0`当做（空）指针使用。同样地，对待`NULL`也是如此。可能不同的是，根据具体实现的不同`NULL`可以被定义为`int`，`long int`等。

在C++98中，这可能导致的主要影响是，函数重载会不能匹配到指针类型的重载函数。

```cpp
void f(int);	// three overloads of f
void f(bool);
void f(void*);

f(0);			// calls f(int), not f(void*)
f(NULL);		// might not compile, but typically calls f(int). Never calls f(void*)
```

上面`f(NULL)`可能不能编译的原因是：如果`NULL`被定义为`0L`，那么实际上`long`转`int`，`long`转`bool`，以及`0L`转`void*`，对编译器来讲是同样好的，所以会产生歧义（模棱两可）。



### C++11 introduced`nullptr`

C++11中引入了`nullptr`，它的实际类型是`std::nullptr_t`（which is a wonderfully circular definition）。

`std::nullptr_t`可以隐式地转换成所有类型的原生指针。

> The type `std::nullptr_t` implicitly converts to all raw pointer types

在上述例子中，如果存在一种参数是指针类型的重载函数，那么就可以使用`nullptr`来调用，避免编译器不能匹配想要正确匹配的重载函数了。

```cpp
/** With examples above **/
f(nullptr); // calls f(void*) overload
```



使用`nullptr`而不是`0`或是`NULL`可以避免重载函数匹配的问题，除此之外，还可以提高代码可读性，尤其是当何`auto`一起使用时（It can also improve **code clarity**, especially when `auto` variables are involved）。下面的例子说明了，使用`nullptr`时，可以一眼就发现`result`实际上是一个指针类型。

```cpp
auto result = findRecord( /* arguments */ );
if (result == 0) { /* ... */ }

auto result = findRecord( /* arguments */ );
if (result == nullptr) { /* ... */ }
```



### Template with `nullptr`

假设有以下三个函数，每个的参数都是一种（不同类型的）指针

```cpp
int f1(std::shared_ptr<Widget> spw);	// call these only when
double f2(std::unique_ptr<Widget> upw);	// the appropriate
bool f3(Widget* pw);					// mutex is locked
```

如果使用`0`和`NULL`，也可以工作（但事实上并不理想）

```cpp
std::mutex f1m, f2m, f3m; // mutexes for f1, f2, and f3
using MuxGuard = std::lock_guard<std::mutex>; // C++11 typedef; see Item 9

{
	MuxGuard g(f1m);		// lock mutex for f1
	auto result = f1(0);	// pass 0 as null ptr to f1
} // unlock mutex

{
	MuxGuard g(f2m);		// lock mutex for f2
	auto result = f2(NULL);	// pass NULL as null ptr to f2
} // unlock mutex

{
	MuxGuard g(f3m);			// lock mutex for f3
	auto result = f3(nullptr);	// pass nullptr as null ptr to f3
} // unlock mutex
```



因为看起来代码调用函数的步骤都是类似的，所以可以写成Template的形式（如果是C++14，返回类型可以直接写成`decltype(auto)`）

```cpp
template<typename FuncType, typename MuxType, typename PtrType>
auto lockAndCall(FuncType func, MuxType& mutex, PtrType ptr) -> decltype(func(ptr)) {
	MuxGuard g(mutex);
	return func(ptr);
}
```

那么相应的调用就如下

```cpp
auto result1 = lockAndCall(f1, f1m, 0);			// error!
auto result2 = lockAndCall(f2, f2m, NULL);		// error!
auto result3 = lockAndCall(f3, f3m, nullptr);	// fine
```

如上注释中所注明，第一个和第二个调用实际上会编译失败。

第一个：因为`0`始终都会被编译器认为是`int`类型，所以模板中`ptr`会被推导为`int`类型，但对于`f1m`而言，它接受的参数却是`std::shared_ptr<Widget>`，而显然`int`不能（隐式地）转换成`std::shared_ptr<Widget>`，所以或编译失败。

第二个：和第一个中的`0`类似，`NULL`按照它被定义的类型，或被编译器认为是`int`或是`int-like`的类型，这将同样导致编译推导`ptr`的类型是`int`或是`int-like`的类型，而`f2m`实际上接收的参数类型是`std::unique_ptr<Widget>`。所以编译失败。

第三个：会编译成功。原因是`nullptr`本身的类型是`std::nullptr_t`，这同样也是编译器推导出来的类型，而`std::nullptr_t`可以隐式地转换成任意一种原生指针（这里的`Widget*`），所以最后编译通过。







## Item 9: Prefer alias declarations to `typedef`



### 使用alias declaration而不是`typedef`的原因

为什么用`using` alias declaration，而不是老式的（C++98）的`typedef`，其中就一定有令人信服的技术原因。

> it’s reasonable to wonder whether there is a solid technical reason for preferring one over the other.



- **原因一（主要）**

  使用`using` alias declaration的主要原因是：**template**。（**`typedef`是不能对template使用**）

  如果对template使用`using` alias declaration，这时叫做 **alias templates**。

  > alias declaration can be templatized, in which case they’re called ***alias templates***
  >
  > With an alias template, it’s a piece of cake.

- 原因二（次要）

  如果是要定义一个函数指针的alias，可以明显看到`using` alias的形式稍微好读一些，但这并不是使用`using` alias的形式的主要原因。

```cpp
// FP is a synonym for a pointer to a function taking an int and
// a const std::string& and returning nothing
typedef void (*FP)(int, const std::string&); // typedef same meaning as above
using FP = void (*)(int, const std::string&); // alias declaration
```

- 原因三（次要）

  Scott Meyers调侃了一下，如果写个很长的类型名称，会增加得腕管综合征的风险。

  > Just thinking about it probably increases the risk of carpal tunnel syndrome.



### Alias declarations (`using`) for templates

#### `using name = qualifier` vs. `typedef`

`using` alias declaration for template的写法

```cpp
template<typename T>						  // MyAllocList<T> is synonym 
using MyAllocList = std::list<T, MyAlloc<T>>; // for std::list<T, MyAlloc<T>>
```

而如果使用`typedef`来写template的alias，就需要在class内部定义类型

```cpp
template<typename T>						// MyAllocList<T>::type
struct MyAllocList {						// is synonym for
	typedef std::list<T, MyAlloc<T>> type;	// std::list<T, MyAlloc<T>>
};

MyAllocList<Widget>::type lw; // client code
```



#### template中使用typedef定义的alias会遇到*dependent type*

更糟糕的是，如果使用`typedef`，当想在一个template中，声明一个如上用`typedef`定义的alias，那么就要用到***dependent type***。

```cpp
// If use typedef as above, then to use this alias in class Widget
template<typename T>
class Widget {							// Widget<T> contains
private:								// a MyAllocList<T>
	typename MyAllocList<T>::type list; // as a data member
};

```

前面加上`typename`关键字的原因是，编译器并不能分辨出`MyAllocList<T>::type`实际上定义了一个类型，还是别的东西，比如说，一个class的member。

Scott Meyers在解释这个dependent type的时候，举了个例子：

> For example, some misguided soul may have concocted something like this:

```cpp
class Wine { /*something*/ };
template<>					// MyAllocList specialization
class MyAllocList<Wine> {	// for when T is Wine
private:
	enum class WineType { White, Red, Rose };
	WineType type; // in this class, type is a data member!
}
```

这个例子是说，如果特化了`MyAllocList`这个class（for class `Wine`），并且在这个特化的class里定义了一个叫做`type`的成员变量，那么当使用`MyAllocList<Wine>::type`的时候，就不再是指一个类型，而是一个特化类的成员了！

但是如果使用`using name = qualifier`形式的alias，情况就不同了

```cpp
// If use "using name = qualifier: as above, then to use this alias in class Widget
template<typename T>
class Widget {
private:
	MyAllocList<T> list; // no "typename", no "::type"
};
```

可以看到，如果使用`using name = qualifier`形式的alias，那么在使用这template alias的时候，就不用在前面加`typename`关键字了。

Scott Meyers解释了，虽然`MyAllocList<T>`看起来像是***dependent type***，但实际上编译器遇到`MyAllocList`知道它是an alias template（而它必须是给类型命名的），所以这里`MyAllocList<T>`对编译器而言，就是*non-dependent type*，这时候，既不需要，也不允许添加`typename`！



#### 使用STL时可能遇到需要添加`typename`的*dependent type*

Scott Meyers提到了在C++11 STL中，几种实际上是利用`typedef`而实现的alias（for template），那么，如果要把它们用于template当中的时候，就需要在它们的前面添加`typename`关键字而告之编译器，这是类型名。

```cpp
std::remove_const<T>::type			// yields T from const T
std::remove_reference<T>::type		// yields T from T& and T&&
std::add_lvalue_reference<T>::type	// yields T& from T
```

C++11的type traits，实际上是由嵌套在template struct里的`typedef`实现的。是的，就是本节讲的要我们避免使用的`typedef`。但它这么做，是由历史原因的。

> C++11 type traits are implemented as nested typedefs inside templatized structs.

实际上，在C++14 STL中，每个对应的type traits都有一个使用`using name = qualifier`实现的alias template，从而可以不需要在template中使用时，前面加上`typename`了。（都是是对应的名字后面加上后缀`_t`）。

```cpp
std::remove_const<T>::type			// C++11: const T → T
std::remove_const_t<T>				// C++14 equivalent
std::remove_reference<T>::type		// C++11: T&/T&& → T
std::remove_reference_t<T>			// C++14 equivalent
std::add_lvalue_reference<T>::type	// C++11: T → T&
std::add_lvalue_reference_t<T>		// C++14 equivalent
```

Scott Meyers建议使用C++14的写法，并提到如何在C++11中使用C++14的写法（虽然不是C++14的实现）

```cpp
template <class T> using remove_const_t = typename remove_const<T>::type;
template <class T> using remove_reference_t = typename remove_reference<T>::type;
template <class T> using add_lvalue_reference_t = typename add_lvalue_reference<T>::type;
```



template metaprogramming = TMP

### Things to Remember

> - `typedef`s don’t support templatization, but alias declarations do.
> - Alias templates avoid the `::type` suffix and, in templates, the `typename` prefix often required to refer to typedefs.
> - C++14 offers alias templates for all the C++11 type traits transformations.





## Item 10: Prefer scoped `enum`s to unscoped `enum`s



*compile constant* ：编译时常量





# Reference Pages

[C++的闭包(closure)](https://zhuanlan.zhihu.com/p/121628510)

[C++ 闭包和匿名函数](https://zhuanlan.zhihu.com/p/303391384)

[C++ most vexing parse（C++最令人烦恼的解析）](https://zhuanlan.zhihu.com/p/391558669)

